// Signature format: 4.0
package androidx.benchmark.macro {

  @RequiresApi(24) public final class ArtMetric extends androidx.benchmark.macro.Metric {
    ctor public ArtMetric();
  }

  public final class BaselineProfileConfig {
    method public kotlin.jvm.functions.Function1<java.lang.String,java.lang.Boolean> getFilterPredicate();
    method public int getMaxIterations();
    method public String? getOutputFilePrefix();
    method public String getPackageName();
    method public kotlin.jvm.functions.Function1<androidx.benchmark.macro.MacrobenchmarkScope,kotlin.Unit> getProfileBlock();
    method public int getStableIterations();
    method public boolean isIncludeInStartupProfile();
    method public boolean isStrictStability();
  }

  public static final class BaselineProfileConfig.Builder {
    ctor public BaselineProfileConfig.Builder(String packageName, kotlin.jvm.functions.Function1<? super androidx.benchmark.macro.MacrobenchmarkScope,kotlin.Unit> profileBlock);
    method public androidx.benchmark.macro.BaselineProfileConfig build();
    method public androidx.benchmark.macro.BaselineProfileConfig.Builder setFilterPredicate(kotlin.jvm.functions.Function1<? super java.lang.String,java.lang.Boolean> filterPredicate);
    method public androidx.benchmark.macro.BaselineProfileConfig.Builder setIncludeInStartupProfile(boolean includeInStartupProfile);
    method public androidx.benchmark.macro.BaselineProfileConfig.Builder setMaxIterations(int maxIterations);
    method public androidx.benchmark.macro.BaselineProfileConfig.Builder setOutputFilePrefix(String outputFilePrefix);
    method public androidx.benchmark.macro.BaselineProfileConfig.Builder setStableIterations(int stableIterations);
    method public androidx.benchmark.macro.BaselineProfileConfig.Builder setStrictStability(boolean strictStability);
  }

  public enum BaselineProfileMode {
    enum_constant public static final androidx.benchmark.macro.BaselineProfileMode Disable;
    enum_constant public static final androidx.benchmark.macro.BaselineProfileMode Require;
    enum_constant public static final androidx.benchmark.macro.BaselineProfileMode UseIfAvailable;
  }

  public final class BaselineProfileResult {
    ctor public BaselineProfileResult();
    ctor public BaselineProfileResult(optional java.util.List<java.lang.String> baselineProfiles, optional java.util.List<java.lang.String> startupProfiles);
    method public java.util.List<java.lang.String> getBaselineProfiles();
    method public java.util.List<java.lang.String> getStartupProfiles();
    property public java.util.List<java.lang.String> baselineProfiles;
    property public java.util.List<java.lang.String> startupProfiles;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class BatteryCharge {
    method public boolean hasMinimumCharge(optional boolean throwOnMissingMetrics);
    field public static final androidx.benchmark.macro.BatteryCharge INSTANCE;
  }

  public abstract sealed class CompilationMode {
    field public static final androidx.benchmark.macro.CompilationMode.Companion Companion;
    field public static final androidx.benchmark.macro.CompilationMode DEFAULT;
  }

  public static final class CompilationMode.Companion {
    property public androidx.benchmark.macro.CompilationMode DEFAULT;
  }

  public static final class CompilationMode.Full extends androidx.benchmark.macro.CompilationMode {
    ctor public CompilationMode.Full();
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMacrobenchmarkApi public static final class CompilationMode.Ignore extends androidx.benchmark.macro.CompilationMode {
    ctor public CompilationMode.Ignore();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static final class CompilationMode.Interpreted extends androidx.benchmark.macro.CompilationMode {
    field public static final androidx.benchmark.macro.CompilationMode.Interpreted INSTANCE;
  }

  @RequiresApi(24) public static final class CompilationMode.None extends androidx.benchmark.macro.CompilationMode {
    ctor public CompilationMode.None();
  }

  @RequiresApi(24) public static final class CompilationMode.Partial extends androidx.benchmark.macro.CompilationMode {
    ctor public CompilationMode.Partial();
    ctor public CompilationMode.Partial(optional androidx.benchmark.macro.BaselineProfileMode baselineProfileMode);
    ctor public CompilationMode.Partial(optional androidx.benchmark.macro.BaselineProfileMode baselineProfileMode, optional @IntRange(from=0L) int warmupIterations);
    method public androidx.benchmark.macro.BaselineProfileMode getBaselineProfileMode();
    method public int getWarmupIterations();
    property public androidx.benchmark.macro.BaselineProfileMode baselineProfileMode;
    property @IntRange(from=0L) public int warmupIterations;
  }

  public final class CompilationModeKt {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static boolean isSupportedWithVmSettings(androidx.benchmark.macro.CompilationMode);
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(message="This Macrobenchmark API is experimental.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION}) public @interface ExperimentalMacrobenchmarkApi {
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(message="This Metric API is experimental.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.CONSTRUCTOR}) public @interface ExperimentalMetricApi {
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public final class FrameTimingGfxInfoMetric extends androidx.benchmark.macro.Metric {
    ctor public FrameTimingGfxInfoMetric();
  }

  public final class FrameTimingMetric extends androidx.benchmark.macro.Metric {
    ctor public FrameTimingMetric();
    ctor @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public FrameTimingMetric(String processNameSuffix);
    ctor @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public FrameTimingMetric(String processNameSuffix, optional String metricNameSuffix);
  }

  public final class MacrobenchmarkScope {
    ctor public MacrobenchmarkScope(String packageName, boolean launchWithClearTask);
    method public void dropKernelPageCache();
    method public void dropShaderCache();
    method public androidx.test.uiautomator.UiDevice getDevice();
    method public Integer? getIteration();
    method public String getPackageName();
    method public void killProcess();
    method @Deprecated public void killProcess(optional boolean useKillAll);
    method public void pressHome();
    method public void pressHome(optional long delayDurationMs);
    method public void startActivityAndWait();
    method public void startActivityAndWait(android.content.Intent intent);
    method public void startActivityAndWait(optional kotlin.jvm.functions.Function1<? super android.content.Intent,kotlin.Unit> block);
    property public androidx.test.uiautomator.UiDevice device;
    property public Integer? iteration;
    property public String packageName;
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public final class MemoryCountersMetric extends androidx.benchmark.macro.TraceMetric {
    ctor public MemoryCountersMetric();
    ctor public MemoryCountersMetric(optional String processNameSuffix);
    ctor public MemoryCountersMetric(optional String processNameSuffix, optional String metricNameSuffix);
    method public java.util.List<androidx.benchmark.macro.Metric.Measurement> getMeasurements(androidx.benchmark.macro.Metric.CaptureInfo captureInfo, androidx.benchmark.traceprocessor.TraceProcessor.Session traceSession);
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public final class MemoryUsageMetric extends androidx.benchmark.macro.TraceMetric {
    ctor public MemoryUsageMetric(androidx.benchmark.macro.MemoryUsageMetric.Mode mode);
    ctor public MemoryUsageMetric(androidx.benchmark.macro.MemoryUsageMetric.Mode mode, optional java.util.List<? extends androidx.benchmark.macro.MemoryUsageMetric.SubMetric> subMetrics);
    ctor public MemoryUsageMetric(androidx.benchmark.macro.MemoryUsageMetric.Mode mode, optional java.util.List<? extends androidx.benchmark.macro.MemoryUsageMetric.SubMetric> subMetrics, optional String processNameSuffix);
    ctor public MemoryUsageMetric(androidx.benchmark.macro.MemoryUsageMetric.Mode mode, optional java.util.List<? extends androidx.benchmark.macro.MemoryUsageMetric.SubMetric> subMetrics, optional String processNameSuffix, optional String metricNameSuffix);
    method public java.util.List<androidx.benchmark.macro.Metric.Measurement> getMeasurements(androidx.benchmark.macro.Metric.CaptureInfo captureInfo, androidx.benchmark.traceprocessor.TraceProcessor.Session traceSession);
  }

  public enum MemoryUsageMetric.Mode {
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.Mode Last;
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.Mode Max;
  }

  public enum MemoryUsageMetric.SubMetric {
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.SubMetric Gpu;
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.SubMetric HeapSize;
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.SubMetric RssAnon;
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.SubMetric RssFile;
    enum_constant public static final androidx.benchmark.macro.MemoryUsageMetric.SubMetric RssShmem;
  }

  public abstract sealed class Metric {
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public static final class Metric.CaptureInfo {
    ctor public Metric.CaptureInfo(int apiLevel, String targetPackageName, String testPackageName, androidx.benchmark.macro.StartupMode? startupMode, optional Long? artMainlineVersion);
    method public static androidx.benchmark.macro.Metric.CaptureInfo forLocalCapture(String targetPackageName, androidx.benchmark.macro.StartupMode? startupMode);
    method public int getApiLevel();
    method public Long? getArtMainlineVersion();
    method public androidx.benchmark.macro.StartupMode? getStartupMode();
    method public String getTargetPackageName();
    method public String getTestPackageName();
    property public int apiLevel;
    property public Long? artMainlineVersion;
    property public androidx.benchmark.macro.StartupMode? startupMode;
    property public String targetPackageName;
    property public String testPackageName;
    field public static final androidx.benchmark.macro.Metric.CaptureInfo.Companion Companion;
  }

  public static final class Metric.CaptureInfo.Companion {
    method public androidx.benchmark.macro.Metric.CaptureInfo forLocalCapture(String targetPackageName, androidx.benchmark.macro.StartupMode? startupMode);
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi @kotlin.ConsistentCopyVisibility public static final class Metric.Measurement {
    ctor public Metric.Measurement(String name, double data);
    ctor public Metric.Measurement(String name, java.util.List<java.lang.Double> dataSamples);
    method public String component1();
    method public java.util.List<java.lang.Double> component2();
    method public boolean component3();
    method public java.util.List<java.lang.Double> getData();
    method public String getName();
    method public boolean getRequireSingleValue();
    property public java.util.List<java.lang.Double> data;
    property public String name;
    property public boolean requireSingleValue;
  }

  public final class MetricResultExtensionsKt {
    method @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public static void assertEqualMeasurements(java.util.List<androidx.benchmark.macro.Metric.Measurement> expected, java.util.List<androidx.benchmark.macro.Metric.Measurement> observed, double threshold);
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public enum PowerCategory {
    enum_constant public static final androidx.benchmark.macro.PowerCategory CPU;
    enum_constant public static final androidx.benchmark.macro.PowerCategory DISPLAY;
    enum_constant public static final androidx.benchmark.macro.PowerCategory GPS;
    enum_constant public static final androidx.benchmark.macro.PowerCategory GPU;
    enum_constant public static final androidx.benchmark.macro.PowerCategory MACHINE_LEARNING;
    enum_constant public static final androidx.benchmark.macro.PowerCategory MEMORY;
    enum_constant public static final androidx.benchmark.macro.PowerCategory NETWORK;
    enum_constant public static final androidx.benchmark.macro.PowerCategory UNCATEGORIZED;
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public enum PowerCategoryDisplayLevel {
    enum_constant public static final androidx.benchmark.macro.PowerCategoryDisplayLevel BREAKDOWN;
    enum_constant public static final androidx.benchmark.macro.PowerCategoryDisplayLevel TOTAL;
  }

  @SuppressCompatibility @RequiresApi(29) @androidx.benchmark.macro.ExperimentalMetricApi public final class PowerMetric extends androidx.benchmark.macro.Metric {
    ctor public PowerMetric(androidx.benchmark.macro.PowerMetric.Type type);
    method public static androidx.benchmark.macro.PowerMetric.Type.Battery Battery();
    method public static androidx.benchmark.macro.PowerMetric.Type.Energy Energy(optional java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel> categories);
    method public static androidx.benchmark.macro.PowerMetric.Type.Power Power(optional java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel> categories);
    method public static boolean deviceBatteryHasMinimumCharge();
    method public static boolean deviceSupportsHighPrecisionTracking();
    field public static final androidx.benchmark.macro.PowerMetric.Companion Companion;
  }

  public static final class PowerMetric.Companion {
    method public androidx.benchmark.macro.PowerMetric.Type.Battery Battery();
    method public androidx.benchmark.macro.PowerMetric.Type.Energy Energy(optional java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel> categories);
    method public androidx.benchmark.macro.PowerMetric.Type.Power Power(optional java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel> categories);
    method public boolean deviceBatteryHasMinimumCharge();
    method public boolean deviceSupportsHighPrecisionTracking();
  }

  public abstract static sealed class PowerMetric.Type {
    method public final java.util.Map<androidx.benchmark.macro.PowerCategory,androidx.benchmark.macro.PowerCategoryDisplayLevel> getCategories();
    method public final void setCategories(java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel>);
    property public final java.util.Map<androidx.benchmark.macro.PowerCategory,androidx.benchmark.macro.PowerCategoryDisplayLevel> categories;
  }

  public static final class PowerMetric.Type.Battery extends androidx.benchmark.macro.PowerMetric.Type {
    ctor public PowerMetric.Type.Battery();
  }

  public static final class PowerMetric.Type.Energy extends androidx.benchmark.macro.PowerMetric.Type {
    ctor public PowerMetric.Type.Energy();
    ctor public PowerMetric.Type.Energy(optional java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel> energyCategories);
  }

  public static final class PowerMetric.Type.Power extends androidx.benchmark.macro.PowerMetric.Type {
    ctor public PowerMetric.Type.Power();
    ctor public PowerMetric.Type.Power(optional java.util.Map<androidx.benchmark.macro.PowerCategory,? extends androidx.benchmark.macro.PowerCategoryDisplayLevel> powerCategories);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class PowerRail {
    method public boolean hasMetrics(optional boolean throwOnMissingMetrics);
    field public static final androidx.benchmark.macro.PowerRail INSTANCE;
  }

  public enum StartupMode {
    enum_constant public static final androidx.benchmark.macro.StartupMode COLD;
    enum_constant public static final androidx.benchmark.macro.StartupMode HOT;
    enum_constant public static final androidx.benchmark.macro.StartupMode WARM;
  }

  @RequiresApi(29) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class StartupTimingLegacyMetric extends androidx.benchmark.macro.Metric {
    ctor public StartupTimingLegacyMetric();
  }

  public final class StartupTimingMetric extends androidx.benchmark.macro.Metric {
    ctor public StartupTimingMetric();
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public abstract class TraceMetric extends androidx.benchmark.macro.Metric {
    ctor public TraceMetric();
    method public abstract java.util.List<androidx.benchmark.macro.Metric.Measurement> getMeasurements(androidx.benchmark.macro.Metric.CaptureInfo captureInfo, androidx.benchmark.traceprocessor.TraceProcessor.Session traceSession);
  }

  public final class TraceProcessorExtensionsKt {
    method @SuppressCompatibility @androidx.benchmark.traceprocessor.ExperimentalTraceProcessorApi public static <T> T runServer(androidx.benchmark.traceprocessor.TraceProcessor.Companion, kotlin.jvm.functions.Function1<? super androidx.benchmark.traceprocessor.TraceProcessor,? extends T> block);
    method @SuppressCompatibility @androidx.benchmark.traceprocessor.ExperimentalTraceProcessorApi public static <T> T runServer(androidx.benchmark.traceprocessor.TraceProcessor.Companion, optional long timeoutMs, kotlin.jvm.functions.Function1<? super androidx.benchmark.traceprocessor.TraceProcessor,? extends T> block);
    method @SuppressCompatibility @CheckResult @androidx.benchmark.traceprocessor.ExperimentalTraceProcessorApi public static androidx.benchmark.traceprocessor.TraceProcessor.Handle startServer(androidx.benchmark.traceprocessor.TraceProcessor.Companion);
    method @SuppressCompatibility @CheckResult @androidx.benchmark.traceprocessor.ExperimentalTraceProcessorApi public static androidx.benchmark.traceprocessor.TraceProcessor.Handle startServer(androidx.benchmark.traceprocessor.TraceProcessor.Companion, optional long timeoutMs);
  }

  @SuppressCompatibility @androidx.benchmark.macro.ExperimentalMetricApi public final class TraceSectionMetric extends androidx.benchmark.macro.Metric {
    ctor public TraceSectionMetric(String sectionName);
    ctor public TraceSectionMetric(String sectionName, optional androidx.benchmark.macro.TraceSectionMetric.Mode mode);
    ctor public TraceSectionMetric(String sectionName, optional androidx.benchmark.macro.TraceSectionMetric.Mode mode, optional String label);
    ctor public TraceSectionMetric(String sectionName, optional androidx.benchmark.macro.TraceSectionMetric.Mode mode, optional String label, optional boolean targetPackageOnly);
  }

  public abstract static sealed class TraceSectionMetric.Mode {
  }

  public static final class TraceSectionMetric.Mode.Average extends androidx.benchmark.macro.TraceSectionMetric.Mode {
    field public static final androidx.benchmark.macro.TraceSectionMetric.Mode.Average INSTANCE;
  }

  public static final class TraceSectionMetric.Mode.Count extends androidx.benchmark.macro.TraceSectionMetric.Mode {
    field public static final androidx.benchmark.macro.TraceSectionMetric.Mode.Count INSTANCE;
  }

  public static final class TraceSectionMetric.Mode.First extends androidx.benchmark.macro.TraceSectionMetric.Mode {
    field public static final androidx.benchmark.macro.TraceSectionMetric.Mode.First INSTANCE;
  }

  public static final class TraceSectionMetric.Mode.Max extends androidx.benchmark.macro.TraceSectionMetric.Mode {
    field public static final androidx.benchmark.macro.TraceSectionMetric.Mode.Max INSTANCE;
  }

  public static final class TraceSectionMetric.Mode.Min extends androidx.benchmark.macro.TraceSectionMetric.Mode {
    field public static final androidx.benchmark.macro.TraceSectionMetric.Mode.Min INSTANCE;
  }

  public static final class TraceSectionMetric.Mode.Sum extends androidx.benchmark.macro.TraceSectionMetric.Mode {
    field public static final androidx.benchmark.macro.TraceSectionMetric.Mode.Sum INSTANCE;
  }

}


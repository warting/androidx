// Signature format: 4.0
package androidx.compose.runtime {

  public abstract class AbstractApplier<T> implements androidx.compose.runtime.Applier<T> {
    ctor public AbstractApplier(T root);
    method public final void clear();
    method public void down(T node);
    method public T getCurrent();
    method public final T getRoot();
    method protected final void move(java.util.List<T>, int from, int to, int count);
    method protected abstract void onClear();
    method protected final void remove(java.util.List<T>, int index, int count);
    method protected void setCurrent(T);
    method public void up();
    property public T current;
    property public final T root;
  }

  public final class ActualAndroid_androidKt {
    method @Deprecated public static androidx.compose.runtime.MonotonicFrameClock getDefaultMonotonicFrameClock();
    property @Deprecated public static androidx.compose.runtime.MonotonicFrameClock DefaultMonotonicFrameClock;
  }

  @kotlin.jvm.JvmDefaultWithCompatibility public interface Applier<N> {
    method public default void apply(kotlin.jvm.functions.Function2<? super N,java.lang.Object?,kotlin.Unit> block, Object? value);
    method public void clear();
    method public void down(N node);
    method public N getCurrent();
    method public void insertBottomUp(int index, N instance);
    method public void insertTopDown(int index, N instance);
    method public void move(int from, int to, int count);
    method public default void onBeginChanges();
    method public default void onEndChanges();
    method public void remove(int index, int count);
    method public default void reuse();
    method public void up();
    property public abstract N current;
  }

  public final class BroadcastFrameClock implements androidx.compose.runtime.MonotonicFrameClock {
    ctor public BroadcastFrameClock();
    ctor public BroadcastFrameClock(optional kotlin.jvm.functions.Function0<kotlin.Unit>? onNewAwaiters);
    method public void cancel(optional java.util.concurrent.CancellationException cancellationException);
    method @BytecodeOnly public <R> R! fold(R!, kotlin.jvm.functions.Function2<? super R!,? super kotlin.coroutines.CoroutineContext.Element!,? extends R!>);
    method @BytecodeOnly public <E extends kotlin.coroutines.CoroutineContext.Element> E? get(kotlin.coroutines.CoroutineContext.Key<E!>);
    method public boolean getHasAwaiters();
    method @BytecodeOnly public kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.CoroutineContext.Key<? extends java.lang.Object!>);
    method @BytecodeOnly public kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext);
    method public void sendFrame(long timeNanos);
    method public suspend <R> Object? withFrameNanos(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R>);
    property public boolean hasAwaiters;
  }

  public fun interface CancellationHandle {
    method public void cancel();
    field public static final androidx.compose.runtime.CancellationHandle.Companion Companion;
  }

  public static final class CancellationHandle.Companion {
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.TYPE, kotlin.annotation.AnnotationTarget.TYPE_PARAMETER, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface Composable {
  }

  @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface ComposableInferredTarget {
    ctor @KotlinOnly public ComposableInferredTarget(String scheme);
    method public abstract String scheme();
    property public abstract String scheme;
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER, kotlin.annotation.AnnotationTarget.TYPE, kotlin.annotation.AnnotationTarget.TYPE_PARAMETER}) public @interface ComposableOpenTarget {
    ctor @KotlinOnly public ComposableOpenTarget(int index);
    method public abstract int index();
    property public abstract int index;
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FILE, kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER, kotlin.annotation.AnnotationTarget.TYPE, kotlin.annotation.AnnotationTarget.TYPE_PARAMETER}) public @interface ComposableTarget {
    ctor @KotlinOnly public ComposableTarget(String applier);
    method public abstract String applier();
    property public abstract String applier;
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.ANNOTATION_CLASS) public @interface ComposableTargetMarker {
    ctor @KotlinOnly public ComposableTargetMarker(optional String description);
    method public abstract String description() default "";
    property public abstract String description;
  }

  public final class ComposablesKt {
    method @KotlinOnly @androidx.compose.runtime.Composable public static inline <T, reified E extends androidx.compose.runtime.Applier<?>> void ComposeNode(kotlin.jvm.functions.Function0<T> factory, kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> update);
    method @KotlinOnly @androidx.compose.runtime.Composable public static inline <T, reified E extends androidx.compose.runtime.Applier<?>> void ComposeNode(kotlin.jvm.functions.Function0<T> factory, kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> update, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @KotlinOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static inline <T, reified E extends androidx.compose.runtime.Applier<?>> void ComposeNode(kotlin.jvm.functions.Function0<T> factory, kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> update, kotlin.jvm.functions.Function1<androidx.compose.runtime.SkippableUpdater<T>,kotlin.Unit> skippableUpdate, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @KotlinOnly @androidx.compose.runtime.Composable public static inline <T, reified E extends androidx.compose.runtime.Applier<?>> void ReusableComposeNode(kotlin.jvm.functions.Function0<T> factory, kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> update);
    method @KotlinOnly @androidx.compose.runtime.Composable public static inline <T, reified E extends androidx.compose.runtime.Applier<?>> void ReusableComposeNode(kotlin.jvm.functions.Function0<T> factory, kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> update, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @KotlinOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static inline <T, reified E extends androidx.compose.runtime.Applier<?>> void ReusableComposeNode(kotlin.jvm.functions.Function0<T> factory, kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> update, kotlin.jvm.functions.Function1<androidx.compose.runtime.SkippableUpdater<T>,kotlin.Unit> skippableUpdate, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @androidx.compose.runtime.Composable public static inline void ReusableContent(Object? key, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void ReusableContent(Object?, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static inline void ReusableContentHost(boolean active, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void ReusableContentHost(boolean, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public static androidx.compose.runtime.Composer getCurrentComposer();
    method @BytecodeOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public static androidx.compose.runtime.Composer getCurrentComposer(androidx.compose.runtime.Composer?, int);
    method @Deprecated @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static int getCurrentCompositeKeyHash();
    method @BytecodeOnly @Deprecated @androidx.compose.runtime.Composable public static int getCurrentCompositeKeyHash(androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static long getCurrentCompositeKeyHashCode();
    method @BytecodeOnly @androidx.compose.runtime.Composable public static long getCurrentCompositeKeyHashCode(androidx.compose.runtime.Composer?, int);
    method @SuppressCompatibility @androidx.compose.runtime.Composable @androidx.compose.runtime.InternalComposeApi @androidx.compose.runtime.ReadOnlyComposable @org.jetbrains.annotations.TestOnly public static androidx.compose.runtime.CompositionContext getCurrentCompositionContext();
    method @BytecodeOnly @SuppressCompatibility @androidx.compose.runtime.Composable @androidx.compose.runtime.InternalComposeApi @androidx.compose.runtime.ReadOnlyComposable @org.jetbrains.annotations.TestOnly public static androidx.compose.runtime.CompositionContext getCurrentCompositionContext(androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionLocalContext getCurrentCompositionLocalContext();
    method @BytecodeOnly @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionLocalContext getCurrentCompositionLocalContext(androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public static androidx.compose.runtime.RecomposeScope getCurrentRecomposeScope();
    method @BytecodeOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public static androidx.compose.runtime.RecomposeScope getCurrentRecomposeScope(androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T key(Object?[] keys, kotlin.jvm.functions.Function0<? extends T> block);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! key(Object![], kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T remember(Object? key1, Object? key2, Object? key3, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! remember(Object?, Object?, Object?, kotlin.jvm.functions.Function0<? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T remember(Object? key1, Object? key2, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! remember(Object?, Object?, kotlin.jvm.functions.Function0<? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T remember(Object? key1, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! remember(Object?, kotlin.jvm.functions.Function0<? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T remember(Object?[] keys, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! remember(Object![], kotlin.jvm.functions.Function0<? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T remember(kotlin.jvm.functions.Function0<? extends T> calculation);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! remember(kotlin.jvm.functions.Function0<? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionContext rememberCompositionContext();
    method @BytecodeOnly @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionContext rememberCompositionContext(androidx.compose.runtime.Composer?, int);
    property @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public static androidx.compose.runtime.Composer currentComposer;
    property @Deprecated @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static int currentCompositeKeyHash;
    property @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable public static long currentCompositeKeyHashCode;
    property @SuppressCompatibility @androidx.compose.runtime.Composable @androidx.compose.runtime.InternalComposeApi @androidx.compose.runtime.ReadOnlyComposable @org.jetbrains.annotations.TestOnly public static androidx.compose.runtime.CompositionContext currentCompositionContext;
    property @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionLocalContext currentCompositionLocalContext;
    property @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public static androidx.compose.runtime.RecomposeScope currentRecomposeScope;
  }

  @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.TYPEALIAS}) public @interface ComposeCompilerApi {
  }

  public interface ComposeNodeLifecycleCallback {
    method public void onDeactivate();
    method public void onRelease();
    method public void onReuse();
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public final class ComposeRuntimeFlags {
    property public boolean isMovableContentUsageTrackingEnabled;
    property public boolean isMovingNestedMovableContentEnabled;
    field public static final androidx.compose.runtime.ComposeRuntimeFlags INSTANCE;
    field public static boolean isMovableContentUsageTrackingEnabled;
    field public static boolean isMovingNestedMovableContentEnabled;
  }

  public sealed interface Composer {
    method @androidx.compose.runtime.ComposeCompilerApi public <V, T> void apply(V value, kotlin.jvm.functions.Function2<? super T,? super V,kotlin.Unit> block);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public androidx.compose.runtime.CompositionContext buildContext();
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(boolean value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(byte value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(char value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(double value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(float value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(int value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(Object? value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(long value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changed(short value);
    method @androidx.compose.runtime.ComposeCompilerApi public default boolean changedInstance(Object? value);
    method public void collectParameterInformation();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public <T> T consume(androidx.compose.runtime.CompositionLocal<T> key);
    method @androidx.compose.runtime.ComposeCompilerApi public <T> void createNode(kotlin.jvm.functions.Function0<? extends T> factory);
    method @androidx.compose.runtime.ComposeCompilerApi public void deactivateToEndGroup(boolean changed);
    method @androidx.compose.runtime.ComposeCompilerApi public void disableReusing();
    method @org.jetbrains.annotations.TestOnly public void disableSourceInformation();
    method @androidx.compose.runtime.ComposeCompilerApi public void enableReusing();
    method @androidx.compose.runtime.ComposeCompilerApi public void endDefaults();
    method @androidx.compose.runtime.ComposeCompilerApi public void endMovableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void endNode();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void endProvider();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void endProviders();
    method @androidx.compose.runtime.ComposeCompilerApi public void endReplaceGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void endReplaceableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public androidx.compose.runtime.ScopeUpdateScope? endRestartGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void endReusableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void endToMarker(int marker);
    method public androidx.compose.runtime.Applier<? extends java.lang.Object?> getApplier();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi @org.jetbrains.annotations.TestOnly public kotlin.coroutines.CoroutineContext getApplyCoroutineContext();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public long getCompositeKeyHashCode();
    method @org.jetbrains.annotations.TestOnly public androidx.compose.runtime.ControlledComposition getComposition();
    method public androidx.compose.runtime.tooling.CompositionData getCompositionData();
    method @Deprecated @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public default int getCompoundKeyHash();
    method public androidx.compose.runtime.CompositionLocalMap getCurrentCompositionLocalMap();
    method public int getCurrentMarker();
    method public boolean getDefaultsInvalid();
    method public boolean getInserting();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public androidx.compose.runtime.RecomposeScope? getRecomposeScope();
    method public Object? getRecomposeScopeIdentity();
    method public boolean getSkipping();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void insertMovableContent(androidx.compose.runtime.MovableContent<? extends java.lang.Object?> value, Object? parameter);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void insertMovableContentReferences(java.util.List<kotlin.Pair<androidx.compose.runtime.MovableContentStateReference,androidx.compose.runtime.MovableContentStateReference?>> references);
    method @androidx.compose.runtime.ComposeCompilerApi public Object joinKey(Object? left, Object? right);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void recordSideEffect(kotlin.jvm.functions.Function0<kotlin.Unit> effect);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void recordUsed(androidx.compose.runtime.RecomposeScope scope);
    method @androidx.compose.runtime.ComposeCompilerApi public Object? rememberedValue();
    method public androidx.compose.runtime.CancellationHandle scheduleFrameEndCallback(kotlin.jvm.functions.Function0<kotlin.Unit> action);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public boolean shouldExecute(boolean parametersChanged, int flags);
    method @androidx.compose.runtime.ComposeCompilerApi public void skipCurrentGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void skipToGroupEnd();
    method public void sourceInformation(String sourceInformation);
    method public void sourceInformationMarkerEnd();
    method public void sourceInformationMarkerStart(int key, String sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public void startDefaults();
    method @androidx.compose.runtime.ComposeCompilerApi public void startMovableGroup(int key, Object? dataKey);
    method @androidx.compose.runtime.ComposeCompilerApi public void startNode();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void startProvider(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object?> value);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void startProviders(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object?>[] values);
    method @androidx.compose.runtime.ComposeCompilerApi public void startReplaceGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public void startReplaceableGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public androidx.compose.runtime.Composer startRestartGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public void startReusableGroup(int key, Object? dataKey);
    method @androidx.compose.runtime.ComposeCompilerApi public void startReusableNode();
    method @androidx.compose.runtime.ComposeCompilerApi public void updateRememberedValue(Object? value);
    method @androidx.compose.runtime.ComposeCompilerApi public void useNode();
    property @androidx.compose.runtime.ComposeCompilerApi public abstract androidx.compose.runtime.Applier<? extends java.lang.Object?> applier;
    property @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi @org.jetbrains.annotations.TestOnly public abstract kotlin.coroutines.CoroutineContext applyCoroutineContext;
    property @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public abstract long compositeKeyHashCode;
    property @org.jetbrains.annotations.TestOnly public abstract androidx.compose.runtime.ControlledComposition composition;
    property public abstract androidx.compose.runtime.tooling.CompositionData compositionData;
    property @Deprecated @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public default int compoundKeyHash;
    property public abstract androidx.compose.runtime.CompositionLocalMap currentCompositionLocalMap;
    property @androidx.compose.runtime.ComposeCompilerApi public abstract int currentMarker;
    property @androidx.compose.runtime.ComposeCompilerApi public abstract boolean defaultsInvalid;
    property @androidx.compose.runtime.ComposeCompilerApi public abstract boolean inserting;
    property @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public abstract androidx.compose.runtime.RecomposeScope? recomposeScope;
    property @androidx.compose.runtime.ComposeCompilerApi public abstract Object? recomposeScopeIdentity;
    property @androidx.compose.runtime.ComposeCompilerApi public abstract boolean skipping;
    field public static final androidx.compose.runtime.Composer.Companion Companion;
  }

  public static final class Composer.Companion {
    method public Object getEmpty();
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public void setDiagnosticStackTraceEnabled(boolean enabled);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeTracingApi public void setTracer(androidx.compose.runtime.CompositionTracer? tracer);
    property public Object Empty;
  }

  public final class ComposerKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static inline <T> T cache(androidx.compose.runtime.Composer, boolean invalid, kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ComposeCompilerApi public static boolean isTraceInProgress();
    method @androidx.compose.runtime.ComposeCompilerApi public static void sourceInformation(androidx.compose.runtime.Composer composer, String sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public static void sourceInformationMarkerEnd(androidx.compose.runtime.Composer composer);
    method @androidx.compose.runtime.ComposeCompilerApi public static void sourceInformationMarkerStart(androidx.compose.runtime.Composer composer, int key, String sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public static void traceEventEnd();
    method @androidx.compose.runtime.ComposeCompilerApi public static void traceEventStart(int key, int dirty1, int dirty2, String info);
    method @BytecodeOnly @Deprecated @androidx.compose.runtime.ComposeCompilerApi public static void traceEventStart(int, String!);
  }

  public final class CompositeKeyHashCode_jvmKt {
    method public static inline long toLong(long);
    method public static inline String toString(long, int radix);
    property public static long EmptyCompositeKeyHashCode;
    field public static final long EmptyCompositeKeyHashCode = 0L; // 0x0L
  }

  public interface Composition {
    method public void dispose();
    method public boolean getHasInvalidations();
    method public boolean isDisposed();
    method public void setContent(kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly public void setContent(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    property public abstract boolean hasInvalidations;
    property public abstract boolean isDisposed;
  }

  public abstract class CompositionContext {
    method public abstract kotlin.coroutines.CoroutineContext getEffectCoroutineContext();
    method public abstract androidx.compose.runtime.CancellationHandle scheduleFrameEndCallback(kotlin.jvm.functions.Function0<kotlin.Unit> action);
    property public abstract kotlin.coroutines.CoroutineContext effectCoroutineContext;
  }

  public final class CompositionKt {
    method public static androidx.compose.runtime.Composition Composition(androidx.compose.runtime.Applier<? extends java.lang.Object?> applier, androidx.compose.runtime.CompositionContext parent);
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.Composition Composition(androidx.compose.runtime.Applier<? extends java.lang.Object?> applier, androidx.compose.runtime.CompositionContext parent, kotlin.coroutines.CoroutineContext recomposeCoroutineContext);
    method @org.jetbrains.annotations.TestOnly public static androidx.compose.runtime.ControlledComposition ControlledComposition(androidx.compose.runtime.Applier<? extends java.lang.Object?> applier, androidx.compose.runtime.CompositionContext parent);
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi @org.jetbrains.annotations.TestOnly public static androidx.compose.runtime.ControlledComposition ControlledComposition(androidx.compose.runtime.Applier<? extends java.lang.Object?> applier, androidx.compose.runtime.CompositionContext parent, kotlin.coroutines.CoroutineContext recomposeCoroutineContext);
    method public static androidx.compose.runtime.ReusableComposition ReusableComposition(androidx.compose.runtime.Applier<? extends java.lang.Object?> applier, androidx.compose.runtime.CompositionContext parent);
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public static kotlin.coroutines.CoroutineContext getRecomposeCoroutineContext(androidx.compose.runtime.ControlledComposition);
    property @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public static kotlin.coroutines.CoroutineContext androidx.compose.runtime.ControlledComposition.recomposeCoroutineContext;
  }

  @androidx.compose.runtime.Stable public abstract sealed class CompositionLocal<T> {
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public final inline T getCurrent();
    method @BytecodeOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public final T! getCurrent(androidx.compose.runtime.Composer?, int);
    property @androidx.compose.runtime.Composable @androidx.compose.runtime.ReadOnlyComposable public final inline T current;
  }

  public interface CompositionLocalAccessorScope {
    method public <T> T getCurrentValue(androidx.compose.runtime.CompositionLocal<T>);
    property public abstract <T> T androidx.compose.runtime.CompositionLocal<T>.currentValue;
  }

  @androidx.compose.runtime.Stable public final class CompositionLocalContext {
  }

  public final class CompositionLocalKt {
    method @androidx.compose.runtime.Composable public static void CompositionLocalProvider(androidx.compose.runtime.CompositionLocalContext context, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void CompositionLocalProvider(androidx.compose.runtime.CompositionLocalContext, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonSkippableComposable public static void CompositionLocalProvider(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object?> value, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void CompositionLocalProvider(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object!>, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonSkippableComposable public static void CompositionLocalProvider(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object?>[] values, kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void CompositionLocalProvider(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object!>![], kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>, androidx.compose.runtime.Composer?, int);
    method public static <T> androidx.compose.runtime.ProvidableCompositionLocal<T> compositionLocalOf(optional androidx.compose.runtime.SnapshotMutationPolicy<T> policy, kotlin.jvm.functions.Function0<? extends T> defaultFactory);
    method public static <T> androidx.compose.runtime.ProvidableCompositionLocal<T> compositionLocalWithComputedDefaultOf(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CompositionLocalAccessorScope,? extends T> defaultComputation);
    method public static <T> androidx.compose.runtime.ProvidableCompositionLocal<T> staticCompositionLocalOf(kotlin.jvm.functions.Function0<? extends T> defaultFactory);
    method @androidx.compose.runtime.Composable public static inline <T> T withCompositionLocal(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object?> value, kotlin.jvm.functions.Function0<? extends T> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! withCompositionLocal(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object!>, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,? extends T!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline <T> T withCompositionLocals(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object?>[] values, kotlin.jvm.functions.Function0<? extends T> content);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> T! withCompositionLocals(androidx.compose.runtime.ProvidedValue<? extends java.lang.Object!>![], kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,? extends T!>, androidx.compose.runtime.Composer?, int);
  }

  public sealed interface CompositionLocalMap {
    method public operator <T> T get(androidx.compose.runtime.CompositionLocal<T> key);
    field public static final androidx.compose.runtime.CompositionLocalMap.Companion Companion;
  }

  public static final class CompositionLocalMap.Companion {
    method public androidx.compose.runtime.CompositionLocalMap getEmpty();
    property public androidx.compose.runtime.CompositionLocalMap Empty;
  }

  public interface CompositionServiceKey<T> {
  }

  public interface CompositionServices {
    method public <T> T? getCompositionService(androidx.compose.runtime.CompositionServiceKey<T> key);
  }

  @SuppressCompatibility @androidx.compose.runtime.InternalComposeTracingApi public interface CompositionTracer {
    method public boolean isTraceInProgress();
    method public void traceEventEnd();
    method public void traceEventStart(int key, int dirty1, int dirty2, String info);
  }

  public sealed interface ControlledComposition extends androidx.compose.runtime.Composition {
    method public void abandonChanges();
    method public void applyChanges();
    method public void applyLateChanges();
    method public void changesApplied();
    method public void composeContent(kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly public void composeContent(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    method public <R> R delegateInvalidations(androidx.compose.runtime.ControlledComposition? to, int groupIndex, kotlin.jvm.functions.Function0<? extends R> block);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void disposeUnusedMovableContent(androidx.compose.runtime.MovableContentState state);
    method public androidx.compose.runtime.ShouldPauseCallback? getAndSetShouldPauseCallback(androidx.compose.runtime.ShouldPauseCallback? shouldPause);
    method public boolean getHasPendingChanges();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void insertMovableContent(java.util.List<kotlin.Pair<androidx.compose.runtime.MovableContentStateReference,androidx.compose.runtime.MovableContentStateReference?>> references);
    method public void invalidateAll();
    method public boolean isComposing();
    method public boolean observesAnyOf(java.util.Set<?> values);
    method public void prepareCompose(kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method public boolean recompose();
    method public void recordModificationsOf(java.util.Set<?> values);
    method public void recordReadOf(Object value);
    method public void recordWriteOf(Object value);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public void verifyConsistent();
    property public abstract boolean hasPendingChanges;
    property public abstract boolean isComposing;
  }

  public final class ControlledRetainScope extends androidx.compose.runtime.RetainScope {
    ctor public ControlledRetainScope();
    method public Object? getExitedValueOrDefault(Object key, Object? defaultIfAbsent);
    method protected void onStartKeepingExitedValues();
    method protected void onStopKeepingExitedValues();
    method protected void saveExitingValue(Object key, Object? value);
    method public void setParentRetainStateProvider(androidx.compose.runtime.RetainStateProvider parent);
    method public void startKeepingExitedValues();
    method public void stopKeepingExitedValues();
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.TYPE) public @interface DisallowComposableCalls {
  }

  public interface DisposableEffectResult {
    method public void dispose();
  }

  public final class DisposableEffectScope {
    ctor public DisposableEffectScope();
    method public inline androidx.compose.runtime.DisposableEffectResult onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> onDisposeEffect);
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.EXPRESSION) public @interface DontMemoize {
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface DoubleState extends androidx.compose.runtime.State<java.lang.Double> {
    method public double getDoubleValue();
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="doubleValue") public default Double getValue();
    property public abstract double doubleValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="doubleValue") public default Double value;
  }

  public final class EffectsKt {
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void DisposableEffect(Object? key1, Object? key2, Object? key3, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectResult> effect);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void DisposableEffect(Object?, Object?, Object?, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope!,? extends androidx.compose.runtime.DisposableEffectResult!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void DisposableEffect(Object? key1, Object? key2, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectResult> effect);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void DisposableEffect(Object?, Object?, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope!,? extends androidx.compose.runtime.DisposableEffectResult!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void DisposableEffect(Object? key1, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectResult> effect);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void DisposableEffect(Object?, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope!,? extends androidx.compose.runtime.DisposableEffectResult!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void DisposableEffect(Object?[] keys, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectResult> effect);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void DisposableEffect(Object![], kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope!,? extends androidx.compose.runtime.DisposableEffectResult!>, androidx.compose.runtime.Composer?, int);
    method @Deprecated @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void DisposableEffect(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectResult> effect);
    method @BytecodeOnly @Deprecated @androidx.compose.runtime.Composable public static void DisposableEffect(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope!,? extends androidx.compose.runtime.DisposableEffectResult!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void LaunchedEffect(Object? key1, Object? key2, Object? key3, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> block);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void LaunchedEffect(Object?, Object?, Object?, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void LaunchedEffect(Object? key1, Object? key2, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> block);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void LaunchedEffect(Object?, Object?, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void LaunchedEffect(Object? key1, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> block);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void LaunchedEffect(Object?, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.NonRestartableComposable public static void LaunchedEffect(Object?[] keys, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> block);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void LaunchedEffect(Object![], kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @Deprecated @androidx.compose.runtime.Composable public static void LaunchedEffect(kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> block);
    method @BytecodeOnly @Deprecated @androidx.compose.runtime.Composable public static void LaunchedEffect(kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ExplicitGroupsComposable @androidx.compose.runtime.NonRestartableComposable public static void SideEffect(kotlin.jvm.functions.Function0<kotlin.Unit> effect);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static void SideEffect(kotlin.jvm.functions.Function0<kotlin.Unit!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static inline kotlinx.coroutines.CoroutineScope rememberCoroutineScope(optional kotlin.jvm.functions.Function0<? extends kotlin.coroutines.CoroutineContext> getContext);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static kotlinx.coroutines.CoroutineScope rememberCoroutineScope(kotlin.jvm.functions.Function0<? extends kotlin.coroutines.CoroutineContext!>?, androidx.compose.runtime.Composer?, int, int);
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR, message="This is an experimental API for Compose and is likely to change before becoming stable.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface ExperimentalComposeApi {
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR, message="This in experimental API that may change frequently and without warning.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.FIELD, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface ExperimentalComposeRuntimeApi {
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface ExplicitGroupsComposable {
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface FloatState extends androidx.compose.runtime.State<java.lang.Float> {
    method public float getFloatValue();
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="floatValue") public default Float getValue();
    property public abstract float floatValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="floatValue") public default Float value;
  }

  public final class ForgetfulRetainScope extends androidx.compose.runtime.RetainScope {
    method public Object? getExitedValueOrDefault(Object key, Object? defaultIfAbsent);
    method protected void onStartKeepingExitedValues();
    method protected void onStopKeepingExitedValues();
    method protected void saveExitingValue(Object key, Object? value);
    field public static final androidx.compose.runtime.ForgetfulRetainScope INSTANCE;
  }

  public final class HotReloaderKt {
    method @org.jetbrains.annotations.TestOnly public static void clearCompositionErrors();
    method @Deprecated @org.jetbrains.annotations.TestOnly public static java.util.List<kotlin.Pair<java.lang.Exception,java.lang.Boolean>> currentCompositionErrors();
    method @org.jetbrains.annotations.TestOnly public static void disableHotReloadMode();
    method @org.jetbrains.annotations.TestOnly public static void invalidateGroupsWithKey(int key);
    method @org.jetbrains.annotations.TestOnly public static void simulateHotReload(Object context);
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface IntState extends androidx.compose.runtime.State<java.lang.Integer> {
    method public int getIntValue();
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="intValue") public default Integer getValue();
    property public abstract int intValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="intValue") public default Integer value;
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR, message="This is internal API for Compose modules that may change frequently and without warning.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER, kotlin.annotation.AnnotationTarget.PROPERTY_SETTER}) public @interface InternalComposeApi {
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR, message="This is internal API that may change frequently and without warning.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface InternalComposeTracingApi {
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface LongState extends androidx.compose.runtime.State<java.lang.Long> {
    method public long getLongValue();
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="longValue") public default Long getValue();
    property public abstract long longValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="longValue") public default Long value;
  }

  @kotlin.jvm.JvmDefaultWithCompatibility public interface MonotonicFrameClock extends kotlin.coroutines.CoroutineContext.Element {
    method public default kotlin.coroutines.CoroutineContext.Key<? extends java.lang.Object?> getKey();
    method public suspend <R> Object? withFrameNanos(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R>);
    property public default kotlin.coroutines.CoroutineContext.Key<? extends java.lang.Object?> key;
    field public static final androidx.compose.runtime.MonotonicFrameClock.Key Key;
  }

  public static final class MonotonicFrameClock.Key implements kotlin.coroutines.CoroutineContext.Key<androidx.compose.runtime.MonotonicFrameClock> {
  }

  public final class MonotonicFrameClockKt {
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.MonotonicFrameClock getMonotonicFrameClock(kotlin.coroutines.CoroutineContext);
    method public static suspend inline <R> Object? withFrameMillis(androidx.compose.runtime.MonotonicFrameClock, kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R>);
    method public static suspend <R> Object? withFrameMillis(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R>);
    method public static suspend <R> Object? withFrameNanos(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R>);
    property @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.MonotonicFrameClock kotlin.coroutines.CoroutineContext.monotonicFrameClock;
  }

  @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public final class MovableContent<P> {
    ctor public MovableContent(kotlin.jvm.functions.Function1<? super P,kotlin.Unit> content);
    ctor @BytecodeOnly public MovableContent(kotlin.jvm.functions.Function3<? super P!,? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    method public kotlin.jvm.functions.Function1<P,kotlin.Unit> getContent();
    property public kotlin.jvm.functions.Function1<P,kotlin.Unit> content;
  }

  public final class MovableContentKt {
    method @androidx.compose.runtime.annotation.RememberInComposition public static kotlin.jvm.functions.Function0<kotlin.Unit> movableContentOf(kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <P> kotlin.jvm.functions.Function1<P,kotlin.Unit> movableContentOf(kotlin.jvm.functions.Function1<? super P,kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <P1, P2> kotlin.jvm.functions.Function2<P1,P2,kotlin.Unit> movableContentOf(kotlin.jvm.functions.Function2<? super P1,? super P2,kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <P1, P2, P3> kotlin.jvm.functions.Function3<P1,P2,P3,kotlin.Unit> movableContentOf(kotlin.jvm.functions.Function3<? super P1,? super P2,? super P3,kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <P1, P2, P3, P4> kotlin.jvm.functions.Function4<P1,P2,P3,P4,kotlin.Unit> movableContentOf(kotlin.jvm.functions.Function4<? super P1,? super P2,? super P3,? super P4,kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.annotation.RememberInComposition public static <P1, P2, P3> kotlin.jvm.functions.Function5<P1!,P2!,P3!,androidx.compose.runtime.Composer!,java.lang.Integer!,kotlin.Unit!> movableContentOf(kotlin.jvm.functions.Function5<? super P1!,? super P2!,? super P3!,? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    method @BytecodeOnly @androidx.compose.runtime.annotation.RememberInComposition public static <P1, P2, P3, P4> kotlin.jvm.functions.Function6<P1!,P2!,P3!,P4!,androidx.compose.runtime.Composer!,java.lang.Integer!,kotlin.Unit!> movableContentOf(kotlin.jvm.functions.Function6<? super P1!,? super P2!,? super P3!,? super P4!,? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <R> kotlin.jvm.functions.Function1<R,kotlin.Unit> movableContentWithReceiverOf(kotlin.jvm.functions.Function1<? super R,kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <R, P> kotlin.jvm.functions.Function2<R,P,kotlin.Unit> movableContentWithReceiverOf(kotlin.jvm.functions.Function2<? super R,? super P,kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <R, P1, P2> kotlin.jvm.functions.Function3<R,P1,P2,kotlin.Unit> movableContentWithReceiverOf(kotlin.jvm.functions.Function3<? super R,? super P1,? super P2,kotlin.Unit> content);
    method @androidx.compose.runtime.annotation.RememberInComposition public static <R, P1, P2, P3> kotlin.jvm.functions.Function4<R,P1,P2,P3,kotlin.Unit> movableContentWithReceiverOf(kotlin.jvm.functions.Function4<? super R,? super P1,? super P2,? super P3,kotlin.Unit> content);
    method @BytecodeOnly @androidx.compose.runtime.annotation.RememberInComposition public static <R, P1, P2> kotlin.jvm.functions.Function5<R!,P1!,P2!,androidx.compose.runtime.Composer!,java.lang.Integer!,kotlin.Unit!> movableContentWithReceiverOf(kotlin.jvm.functions.Function5<? super R!,? super P1!,? super P2!,? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    method @BytecodeOnly @androidx.compose.runtime.annotation.RememberInComposition public static <R, P1, P2, P3> kotlin.jvm.functions.Function6<R!,P1!,P2!,P3!,androidx.compose.runtime.Composer!,java.lang.Integer!,kotlin.Unit!> movableContentWithReceiverOf(kotlin.jvm.functions.Function6<? super R!,? super P1!,? super P2!,? super P3!,? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
  }

  @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public final class MovableContentState {
  }

  @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public final class MovableContentStateReference {
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface MutableDoubleState extends androidx.compose.runtime.DoubleState androidx.compose.runtime.MutableState<java.lang.Double> {
    method public void setDoubleValue(double);
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="doubleValue") public default void setValue(double);
    property public abstract double doubleValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="doubleValue") public default Double value;
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface MutableFloatState extends androidx.compose.runtime.FloatState androidx.compose.runtime.MutableState<java.lang.Float> {
    method public void setFloatValue(float);
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="floatValue") public default void setValue(float);
    property public abstract float floatValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="floatValue") public default Float value;
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface MutableIntState extends androidx.compose.runtime.IntState androidx.compose.runtime.MutableState<java.lang.Integer> {
    method public void setIntValue(int);
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="intValue") public default void setValue(int);
    property public abstract int intValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="intValue") public default Integer value;
  }

  @androidx.compose.runtime.Stable @kotlin.jvm.JvmDefaultWithCompatibility public interface MutableLongState extends androidx.compose.runtime.LongState androidx.compose.runtime.MutableState<java.lang.Long> {
    method public void setLongValue(long);
    method @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="longValue") public default void setValue(long);
    property public abstract long longValue;
    property @androidx.compose.runtime.snapshots.AutoboxingStateValueProperty(preferredPropertyName="longValue") public default Long value;
  }

  @androidx.compose.runtime.Stable public interface MutableState<T> extends androidx.compose.runtime.State<T> {
    method public operator T component1();
    method public operator kotlin.jvm.functions.Function1<T,kotlin.Unit> component2();
    method public void setValue(T);
    property public abstract T value;
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FILE}) public @interface NoLiveLiterals {
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface NonRestartableComposable {
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface NonSkippableComposable {
  }

  public sealed interface PausableComposition extends androidx.compose.runtime.ReusableComposition {
    method public androidx.compose.runtime.PausedComposition setPausableContent(kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly public androidx.compose.runtime.PausedComposition setPausableContent(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
    method public androidx.compose.runtime.PausedComposition setPausableContentWithReuse(kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly public androidx.compose.runtime.PausedComposition setPausableContentWithReuse(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
  }

  public final class PausableCompositionKt {
    method public static androidx.compose.runtime.PausableComposition PausableComposition(androidx.compose.runtime.Applier<? extends java.lang.Object?> applier, androidx.compose.runtime.CompositionContext parent);
  }

  public final class PausableMonotonicFrameClock implements androidx.compose.runtime.MonotonicFrameClock {
    ctor public PausableMonotonicFrameClock(androidx.compose.runtime.MonotonicFrameClock frameClock);
    method @BytecodeOnly public <R> R! fold(R!, kotlin.jvm.functions.Function2<? super R!,? super kotlin.coroutines.CoroutineContext.Element!,? extends R!>);
    method @BytecodeOnly public <E extends kotlin.coroutines.CoroutineContext.Element> E? get(kotlin.coroutines.CoroutineContext.Key<E!>);
    method public boolean isPaused();
    method @BytecodeOnly public kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.CoroutineContext.Key<? extends java.lang.Object!>);
    method public void pause();
    method @BytecodeOnly public kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext);
    method public void resume();
    method public suspend <R> Object? withFrameNanos(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R>);
    property public boolean isPaused;
  }

  public sealed interface PausedComposition {
    method public void apply();
    method public void cancel();
    method public boolean isApplied();
    method public boolean isCancelled();
    method public boolean isComplete();
    method public boolean resume(androidx.compose.runtime.ShouldPauseCallback shouldPause);
    property public abstract boolean isApplied;
    property public abstract boolean isCancelled;
    property public abstract boolean isComplete;
  }

  public final class PrimitiveSnapshotStateKt {
    method public static inline operator float getValue(androidx.compose.runtime.FloatState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static androidx.compose.runtime.MutableFloatState mutableFloatStateOf(float value);
    method public static inline operator void setValue(androidx.compose.runtime.MutableFloatState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property, float value);
  }

  public interface ProduceStateScope<T> extends androidx.compose.runtime.MutableState<T> kotlinx.coroutines.CoroutineScope {
    method public suspend Object? awaitDispose(kotlin.jvm.functions.Function0<kotlin.Unit> onDispose, kotlin.coroutines.Continuation<? extends java.lang.Object?>);
  }

  @androidx.compose.runtime.Stable public abstract class ProvidableCompositionLocal<T> extends androidx.compose.runtime.CompositionLocal<T> {
    method public final infix androidx.compose.runtime.ProvidedValue<T> provides(T value);
    method public final infix androidx.compose.runtime.ProvidedValue<T> providesComputed(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CompositionLocalAccessorScope,? extends T> compute);
    method public final infix androidx.compose.runtime.ProvidedValue<T> providesDefault(T value);
  }

  public final class ProvidedValue<T> {
    method public boolean getCanOverride();
    method public androidx.compose.runtime.CompositionLocal<T> getCompositionLocal();
    method public T getValue();
    property public boolean canOverride;
    property public androidx.compose.runtime.CompositionLocal<T> compositionLocal;
    property public T value;
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface ReadOnlyComposable {
  }

  public interface RecomposeScope {
    method public void invalidate();
  }

  public final class Recomposer extends androidx.compose.runtime.CompositionContext {
    ctor public Recomposer(kotlin.coroutines.CoroutineContext effectCoroutineContext);
    method public androidx.compose.runtime.RecomposerInfo asRecomposerInfo();
    method public suspend Object? awaitIdle(kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method public void cancel();
    method public void close();
    method public long getChangeCount();
    method public kotlinx.coroutines.flow.StateFlow<androidx.compose.runtime.Recomposer.State> getCurrentState();
    method public kotlin.coroutines.CoroutineContext getEffectCoroutineContext();
    method public boolean getHasPendingWork();
    method @Deprecated public kotlinx.coroutines.flow.Flow<androidx.compose.runtime.Recomposer.State> getState();
    method public suspend Object? join(kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method public void pauseCompositionFrameClock();
    method public void resumeCompositionFrameClock();
    method public suspend Object? runRecomposeAndApplyChanges(kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi public suspend Object? runRecomposeConcurrentlyAndApplyChanges(kotlin.coroutines.CoroutineContext recomposeCoroutineContext, kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method public androidx.compose.runtime.CancellationHandle scheduleFrameEndCallback(kotlin.jvm.functions.Function0<kotlin.Unit> action);
    property public long changeCount;
    property public kotlinx.coroutines.flow.StateFlow<androidx.compose.runtime.Recomposer.State> currentState;
    property public kotlin.coroutines.CoroutineContext effectCoroutineContext;
    property public boolean hasPendingWork;
    property @Deprecated public kotlinx.coroutines.flow.Flow<androidx.compose.runtime.Recomposer.State> state;
    field public static final androidx.compose.runtime.Recomposer.Companion Companion;
  }

  public static final class Recomposer.Companion {
    method public kotlinx.coroutines.flow.StateFlow<java.util.Set<androidx.compose.runtime.RecomposerInfo>> getRunningRecomposers();
    property public kotlinx.coroutines.flow.StateFlow<java.util.Set<androidx.compose.runtime.RecomposerInfo>> runningRecomposers;
  }

  public enum Recomposer.State {
    enum_constant public static final androidx.compose.runtime.Recomposer.State Idle;
    enum_constant public static final androidx.compose.runtime.Recomposer.State Inactive;
    enum_constant public static final androidx.compose.runtime.Recomposer.State InactivePendingWork;
    enum_constant public static final androidx.compose.runtime.Recomposer.State PendingWork;
    enum_constant public static final androidx.compose.runtime.Recomposer.State ShutDown;
    enum_constant public static final androidx.compose.runtime.Recomposer.State ShuttingDown;
  }

  public interface RecomposerInfo {
    method public long getChangeCount();
    method public boolean getHasPendingWork();
    method public kotlinx.coroutines.flow.Flow<androidx.compose.runtime.Recomposer.State> getState();
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public default androidx.compose.runtime.tooling.CompositionObserverHandle? observe(androidx.compose.runtime.tooling.CompositionRegistrationObserver observer);
    property public abstract long changeCount;
    property public abstract boolean hasPendingWork;
    property public abstract kotlinx.coroutines.flow.Flow<androidx.compose.runtime.Recomposer.State> state;
  }

  public final class RecomposerKt {
    method public static suspend <R> Object? withRunningRecomposer(kotlin.jvm.functions.Function3<? super kotlinx.coroutines.CoroutineScope,? super androidx.compose.runtime.Recomposer,? super kotlin.coroutines.Continuation<? super R>,? extends java.lang.Object?> block, kotlin.coroutines.Continuation<? super R>);
  }

  public interface RememberObserver {
    method public void onAbandoned();
    method public void onForgotten();
    method public void onRemembered();
  }

  public final class RetainKt {
    method public static androidx.compose.runtime.ProvidableCompositionLocal<androidx.compose.runtime.RetainScope> getLocalRetainScope();
    method @KotlinOnly @androidx.compose.runtime.Composable public static inline <reified T> T retain(java.lang.Object?... keys, kotlin.jvm.functions.Function0<T> calculation);
    method @KotlinOnly @androidx.compose.runtime.Composable public static inline <reified T> T retain(kotlin.jvm.functions.Function0<T> calculation);
    property public static androidx.compose.runtime.ProvidableCompositionLocal<androidx.compose.runtime.RetainScope> LocalRetainScope;
  }

  public interface RetainObserver {
    method public void onEnteredComposition();
    method public void onExitedComposition();
    method public void onRetained();
    method public void onRetired();
  }

  public abstract class RetainScope implements androidx.compose.runtime.RetainStateProvider {
    ctor public RetainScope();
    method public final void addRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    method public abstract Object? getExitedValueOrDefault(Object key, Object? defaultIfAbsent);
    method public final boolean isKeepingExitedValues();
    method protected abstract void onStartKeepingExitedValues();
    method protected abstract void onStopKeepingExitedValues();
    method public final void removeRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    method protected final void requestKeepExitedValues();
    method protected abstract void saveExitingValue(Object key, Object? value);
    method protected final void unRequestKeepExitedValues();
    property public final boolean isKeepingExitedValues;
  }

  public interface RetainStateProvider {
    method public void addRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    method public boolean isKeepingExitedValues();
    method public void removeRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    property public abstract boolean isKeepingExitedValues;
  }

  @androidx.compose.runtime.Stable public static final class RetainStateProvider.AlwaysKeepExitedValues implements androidx.compose.runtime.RetainStateProvider {
    method public void addRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    method public boolean isKeepingExitedValues();
    method public void removeRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    property public boolean isKeepingExitedValues;
    field public static final androidx.compose.runtime.RetainStateProvider.AlwaysKeepExitedValues INSTANCE;
  }

  @androidx.compose.runtime.Stable public static final class RetainStateProvider.NeverKeepExitedValues implements androidx.compose.runtime.RetainStateProvider {
    method public void addRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    method public boolean isKeepingExitedValues();
    method public void removeRetainStateObserver(androidx.compose.runtime.RetainStateProvider.RetainStateObserver observer);
    property public boolean isKeepingExitedValues;
    field public static final androidx.compose.runtime.RetainStateProvider.NeverKeepExitedValues INSTANCE;
  }

  public static interface RetainStateProvider.RetainStateObserver {
    method public void onStartKeepingExitedValues();
    method public void onStopKeepingExitedValues();
  }

  public sealed interface ReusableComposition extends androidx.compose.runtime.Composition {
    method public void deactivate();
    method public void setContentWithReuse(kotlin.jvm.functions.Function0<kotlin.Unit> content);
    method @BytecodeOnly public void setContentWithReuse(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer!,? super java.lang.Integer!,kotlin.Unit!>);
  }

  @androidx.compose.runtime.ComposeCompilerApi public interface ScopeUpdateScope {
    method public void updateScope(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer,? super java.lang.Integer,kotlin.Unit> block);
  }

  public fun interface ShouldPauseCallback {
    method public boolean shouldPause();
  }

  @kotlin.jvm.JvmInline public final value class SkippableUpdater<T> {
    ctor @KotlinOnly public <T> SkippableUpdater(androidx.compose.runtime.Composer composer);
    method @BytecodeOnly public static androidx.compose.runtime.SkippableUpdater! box-impl(androidx.compose.runtime.Composer!);
    method @BytecodeOnly public static <T> androidx.compose.runtime.Composer constructor-impl(androidx.compose.runtime.Composer);
    method @BytecodeOnly public androidx.compose.runtime.Composer! unbox-impl();
    method @KotlinOnly public inline void update(kotlin.jvm.functions.Function1<androidx.compose.runtime.Updater<T>,kotlin.Unit> block);
    method @BytecodeOnly public static void update-impl(androidx.compose.runtime.Composer!, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T!>!,kotlin.Unit!>);
  }

  public final class SnapshotDoubleStateKt {
    method public static inline operator double getValue(androidx.compose.runtime.DoubleState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static androidx.compose.runtime.MutableDoubleState mutableDoubleStateOf(double value);
    method public static inline operator void setValue(androidx.compose.runtime.MutableDoubleState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property, double value);
  }

  public final class SnapshotIntStateKt {
    method public static inline operator int getValue(androidx.compose.runtime.IntState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static androidx.compose.runtime.MutableIntState mutableIntStateOf(int value);
    method public static inline operator void setValue(androidx.compose.runtime.MutableIntState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property, int value);
  }

  public final class SnapshotLongStateKt {
    method public static inline operator long getValue(androidx.compose.runtime.LongState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static androidx.compose.runtime.MutableLongState mutableLongStateOf(long value);
    method public static inline operator void setValue(androidx.compose.runtime.MutableLongState, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property, long value);
  }

  @kotlin.jvm.JvmDefaultWithCompatibility public interface SnapshotMutationPolicy<T> {
    method public boolean equivalent(T a, T b);
    method public default T? merge(T previous, T current, T applied);
  }

  public final class SnapshotStateExtensionsKt {
    method @androidx.compose.runtime.Stable public static androidx.compose.runtime.DoubleState asDoubleState(androidx.compose.runtime.State<java.lang.Double>);
    method @androidx.compose.runtime.Stable public static androidx.compose.runtime.FloatState asFloatState(androidx.compose.runtime.State<java.lang.Float>);
    method @androidx.compose.runtime.Stable public static androidx.compose.runtime.IntState asIntState(androidx.compose.runtime.State<java.lang.Integer>);
    method @androidx.compose.runtime.Stable public static androidx.compose.runtime.LongState asLongState(androidx.compose.runtime.State<java.lang.Long>);
  }

  public final class SnapshotStateKt {
    method @androidx.compose.runtime.Composable public static <T extends R, R> androidx.compose.runtime.State<R> collectAsState(kotlinx.coroutines.flow.Flow<? extends T>, R initial, optional kotlin.coroutines.CoroutineContext context);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T extends R, R> androidx.compose.runtime.State<R!> collectAsState(kotlinx.coroutines.flow.Flow<? extends T!>, R!, kotlin.coroutines.CoroutineContext?, androidx.compose.runtime.Composer?, int, int);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> collectAsState(kotlinx.coroutines.flow.StateFlow<? extends T>, optional kotlin.coroutines.CoroutineContext context);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> collectAsState(kotlinx.coroutines.flow.StateFlow<? extends T!>, kotlin.coroutines.CoroutineContext?, androidx.compose.runtime.Composer?, int, int);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.State<T> derivedStateOf(androidx.compose.runtime.SnapshotMutationPolicy<T> policy, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.State<T> derivedStateOf(kotlin.jvm.functions.Function0<? extends T> calculation);
    method public static inline operator <T> T getValue(androidx.compose.runtime.State<? extends T>, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> mutableStateListOf();
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> mutableStateListOf(T... elements);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> mutableStateMapOf();
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> mutableStateMapOf(kotlin.Pair<? extends K,? extends V>... pairs);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.MutableState<T> mutableStateOf(T value, optional androidx.compose.runtime.SnapshotMutationPolicy<T> policy);
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.snapshots.SnapshotStateSet<T> mutableStateSetOf();
    method @androidx.compose.runtime.snapshots.StateFactoryMarker public static <T> androidx.compose.runtime.snapshots.SnapshotStateSet<T> mutableStateSetOf(T... elements);
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> neverEqualPolicy();
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T initialValue, Object? key1, Object? key2, Object? key3, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> producer);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> produceState(T!, Object?, Object?, Object?, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T!>!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T initialValue, Object? key1, Object? key2, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> producer);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> produceState(T!, Object?, Object?, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T!>!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T initialValue, Object? key1, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> producer);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> produceState(T!, Object?, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T!>!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T initialValue, Object?[] keys, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> producer);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> produceState(T!, Object![], kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T!>!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T initialValue, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,? extends java.lang.Object?> producer);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> produceState(T!, kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T!>!,? super kotlin.coroutines.Continuation<? super kotlin.Unit!>!,? extends java.lang.Object!>, androidx.compose.runtime.Composer?, int);
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> referentialEqualityPolicy();
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> rememberUpdatedState(T newValue);
    method @BytecodeOnly @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T!> rememberUpdatedState(T!, androidx.compose.runtime.Composer?, int);
    method public static inline operator <T> void setValue(androidx.compose.runtime.MutableState<T>, Object? thisObj, kotlin.reflect.KProperty<? extends java.lang.Object?> property, T value);
    method public static <T> kotlinx.coroutines.flow.Flow<T> snapshotFlow(kotlin.jvm.functions.Function0<? extends T> block);
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> structuralEqualityPolicy();
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> toMutableStateList(java.util.Collection<? extends T>);
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> toMutableStateMap(Iterable<? extends kotlin.Pair<? extends K,? extends V>>);
  }

  @androidx.compose.runtime.Stable public interface State<T> {
    method public T getValue();
    property public abstract T value;
  }

  @kotlin.jvm.JvmInline public final value class Updater<T> {
    ctor @KotlinOnly public <T> Updater(androidx.compose.runtime.Composer composer);
    method @BytecodeOnly public static androidx.compose.runtime.Updater! box-impl(androidx.compose.runtime.Composer!);
    method @BytecodeOnly public static <T> androidx.compose.runtime.Composer constructor-impl(androidx.compose.runtime.Composer);
    method @KotlinOnly public void init(kotlin.jvm.functions.Function1<T,kotlin.Unit> block);
    method @BytecodeOnly public static void init-impl(androidx.compose.runtime.Composer!, kotlin.jvm.functions.Function1<? super T!,kotlin.Unit!>);
    method @KotlinOnly public void reconcile(kotlin.jvm.functions.Function1<T,kotlin.Unit> block);
    method @BytecodeOnly public static void reconcile-impl(androidx.compose.runtime.Composer!, kotlin.jvm.functions.Function1<? super T!,kotlin.Unit!>);
    method @KotlinOnly public inline void set(int value, kotlin.jvm.functions.Function2<T,java.lang.Integer,kotlin.Unit> block);
    method @KotlinOnly public <V> void set(V value, kotlin.jvm.functions.Function2<T,V,kotlin.Unit> block);
    method @BytecodeOnly public static void set-impl(androidx.compose.runtime.Composer!, int, kotlin.jvm.functions.Function2<? super T!,? super java.lang.Integer!,kotlin.Unit!>);
    method @BytecodeOnly public static <V> void set-impl(androidx.compose.runtime.Composer!, V!, kotlin.jvm.functions.Function2<? super T!,? super V!,kotlin.Unit!>);
    method @BytecodeOnly public androidx.compose.runtime.Composer! unbox-impl();
    method @KotlinOnly public inline void update(int value, kotlin.jvm.functions.Function2<T,java.lang.Integer,kotlin.Unit> block);
    method @KotlinOnly public <V> void update(V value, kotlin.jvm.functions.Function2<T,V,kotlin.Unit> block);
    method @BytecodeOnly public static void update-impl(androidx.compose.runtime.Composer!, int, kotlin.jvm.functions.Function2<? super T!,? super java.lang.Integer!,kotlin.Unit!>);
    method @BytecodeOnly public static <V> void update-impl(androidx.compose.runtime.Composer!, V!, kotlin.jvm.functions.Function2<? super T!,? super V!,kotlin.Unit!>);
  }

  @Deprecated public typealias CheckResult = androidx.annotation.CheckResult;

  public typealias CompositeKeyHashCode = long;

}

package androidx.compose.runtime.collection {

  public final class MutableVector<T> implements java.util.RandomAccess {
    method public void add(int index, T element);
    method public boolean add(T element);
    method public inline boolean addAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean addAll(int index, androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method public boolean addAll(int index, java.util.List<? extends T> elements);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public inline boolean addAll(java.util.List<? extends T> elements);
    method public boolean addAll(T[] elements);
    method public inline boolean any(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public java.util.List<T> asMutableList();
    method public void clear();
    method public operator boolean contains(T element);
    method public boolean containsAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean containsAll(java.util.Collection<? extends T> elements);
    method public boolean containsAll(java.util.List<? extends T> elements);
    method public boolean contentEquals(androidx.compose.runtime.collection.MutableVector<T> other);
    method public inline void ensureCapacity(int capacity);
    method public T first();
    method public inline T first(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline T? firstOrNull();
    method public inline T? firstOrNull(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline <R> R fold(R initial, kotlin.jvm.functions.Function2<? super R,? super T,? extends R> operation);
    method public inline <R> R foldIndexed(R initial, kotlin.jvm.functions.Function3<? super java.lang.Integer,? super R,? super T,? extends R> operation);
    method public inline <R> R foldRight(R initial, kotlin.jvm.functions.Function2<? super T,? super R,? extends R> operation);
    method public inline <R> R foldRightIndexed(R initial, kotlin.jvm.functions.Function3<? super java.lang.Integer,? super T,? super R,? extends R> operation);
    method public inline void forEach(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void forEachIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,kotlin.Unit> block);
    method public inline void forEachReversed(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void forEachReversedIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,kotlin.Unit> block);
    method public inline operator T get(int index);
    method public inline kotlin.ranges.IntRange getIndices();
    method public inline int getLastIndex();
    method public int getSize();
    method public int indexOf(T element);
    method public inline int indexOfFirst(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline int indexOfLast(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline boolean isEmpty();
    method public inline boolean isNotEmpty();
    method public T last();
    method public inline T last(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public int lastIndexOf(T element);
    method public inline T? lastOrNull();
    method public inline T? lastOrNull(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method @KotlinOnly public inline <reified R> R[] map(kotlin.jvm.functions.Function1<T,R> transform);
    method @KotlinOnly public inline <reified R> R[] mapIndexed(kotlin.jvm.functions.Function2<java.lang.Integer,T,R> transform);
    method @KotlinOnly public inline <reified R> androidx.compose.runtime.collection.MutableVector<R> mapIndexedNotNull(kotlin.jvm.functions.Function2<java.lang.Integer,T,R?> transform);
    method @KotlinOnly public inline <reified R> androidx.compose.runtime.collection.MutableVector<R> mapNotNull(kotlin.jvm.functions.Function1<T,R?> transform);
    method public inline operator void minusAssign(T element);
    method public inline operator void plusAssign(T element);
    method public boolean remove(T element);
    method public boolean removeAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean removeAll(java.util.Collection<? extends T> elements);
    method public boolean removeAll(java.util.List<? extends T> elements);
    method public T removeAt(int index);
    method public inline void removeIf(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public void removeRange(int start, int end);
    method public boolean retainAll(java.util.Collection<? extends T> elements);
    method public inline boolean reversedAny(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public operator T set(int index, T element);
    method public void sortWith(java.util.Comparator<T> comparator);
    method public inline int sumBy(kotlin.jvm.functions.Function1<? super T,java.lang.Integer> selector);
    property public inline kotlin.ranges.IntRange indices;
    property public inline int lastIndex;
    property public int size;
  }

  public final class MutableVectorKt {
    method @KotlinOnly public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T> MutableVector(optional int capacity);
    method @KotlinOnly public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T> MutableVector(int size, kotlin.jvm.functions.Function1<java.lang.Integer,T> init);
    method @KotlinOnly public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T> mutableVectorOf();
    method @KotlinOnly public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T> mutableVectorOf(T... elements);
  }

}

package androidx.compose.runtime.internal {

  @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.Stable public interface ComposableLambda extends kotlin.jvm.functions.Function2<androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function10<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function11<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function13<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function14<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function15<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function16<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function17<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function18<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function19<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function20<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function21<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function3<java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function4<java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function5<java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function6<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function7<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function8<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> kotlin.jvm.functions.Function9<java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,java.lang.Object?,androidx.compose.runtime.Composer,java.lang.Integer,java.lang.Object?> {
  }

  public final class ComposableLambdaKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda composableLambda(androidx.compose.runtime.Composer composer, int key, boolean tracked, Object block);
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda composableLambdaInstance(int key, boolean tracked, Object block);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda rememberComposableLambda(int key, boolean tracked, Object block);
    method @BytecodeOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda rememberComposableLambda(int, boolean, Object, androidx.compose.runtime.Composer?, int);
  }

  @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.Stable public interface ComposableLambdaN extends kotlin.jvm.functions.FunctionN<java.lang.Object?> {
  }

  public final class ComposableLambdaN_jvmKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN composableLambdaN(androidx.compose.runtime.Composer composer, int key, boolean tracked, int arity, Object block);
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN composableLambdaNInstance(int key, boolean tracked, int arity, Object block);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN rememberComposableLambdaN(int key, boolean tracked, int arity, Object block);
    method @BytecodeOnly @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN rememberComposableLambdaN(int, boolean, int, Object, androidx.compose.runtime.Composer?, int);
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.CONSTRUCTOR}) public @interface Decoy {
    ctor @KotlinOnly public Decoy(String targetName, java.lang.String... signature);
    method public abstract String[] signature();
    method public abstract String targetName();
    property public abstract String[] signature;
    property public abstract String targetName;
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeApi @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.CONSTRUCTOR}) public @interface DecoyImplementation {
    ctor @KotlinOnly public DecoyImplementation(String name, long id);
    method public abstract long id();
    method public abstract String name();
    property public abstract long id;
    property public abstract String name;
  }

  public final class DecoyKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static Void illegalDecoyCallException(String fName);
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Repeatable @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION}) public @interface FunctionKeyMeta {
    ctor @KotlinOnly public FunctionKeyMeta(int key, int startOffset, int endOffset);
    method public abstract int endOffset();
    method public abstract int key();
    method public abstract int startOffset();
    property public abstract int endOffset;
    property public abstract int key;
    property public abstract int startOffset;
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Repeatable @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION}) public static @interface FunctionKeyMeta.Container {
    method public abstract androidx.compose.runtime.internal.FunctionKeyMeta[] value();
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.CLASS) public @interface FunctionKeyMetaClass {
    ctor @KotlinOnly public FunctionKeyMetaClass(String file);
    method public abstract String file();
    property public abstract String file;
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.CLASS) public @interface LiveLiteralFileInfo {
    ctor @KotlinOnly public LiveLiteralFileInfo(String file);
    method public abstract String file();
    property public abstract String file;
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.FUNCTION) public @interface LiveLiteralInfo {
    ctor @KotlinOnly public LiveLiteralInfo(String key, int offset);
    method public abstract String key();
    method public abstract int offset();
    property public abstract String key;
    property public abstract int offset;
  }

  public final class LiveLiteralKt {
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public static void enableLiveLiterals();
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public static boolean isLiveLiteralsEnabled();
    method @SuppressCompatibility @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.InternalComposeApi public static <T> androidx.compose.runtime.State<T> liveLiteral(String key, T value);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public static void updateLiveLiteralValue(String key, Object? value);
    property @SuppressCompatibility @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.InternalComposeApi public static boolean isLiveLiteralsEnabled;
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.CLASS) public @interface StabilityInferred {
    ctor @KotlinOnly public StabilityInferred(int parameters);
    method public abstract int parameters();
    property public abstract int parameters;
  }

}

package androidx.compose.runtime.reflect {

  public final class ComposableMethod {
    method public java.lang.reflect.Method asMethod();
    method public int getParameterCount();
    method public Class<? extends java.lang.Object?>[] getParameterTypes();
    method public java.lang.reflect.Parameter[] getParameters();
    method public operator Object? invoke(androidx.compose.runtime.Composer composer, Object? instance, java.lang.Object?... args);
    property public int parameterCount;
    property public Class<? extends java.lang.Object?>[] parameterTypes;
    property public java.lang.reflect.Parameter[] parameters;
  }

  public final class ComposableMethodKt {
    method public static androidx.compose.runtime.reflect.ComposableMethod? asComposableMethod(java.lang.reflect.Method);
    method @kotlin.jvm.Throws(exceptionClasses=NoSuchMethodException::class) public static androidx.compose.runtime.reflect.ComposableMethod getDeclaredComposableMethod(Class<? extends java.lang.Object?>, String methodName, Class<? extends java.lang.Object?>... args) throws java.lang.NoSuchMethodException;
  }

}

package androidx.compose.runtime.snapshots {

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY_SETTER, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER}) public @interface AutoboxingStateValueProperty {
    ctor @KotlinOnly public AutoboxingStateValueProperty(String preferredPropertyName);
    method public abstract String preferredPropertyName();
    property public abstract String preferredPropertyName;
  }

  public class MutableSnapshot extends androidx.compose.runtime.snapshots.Snapshot {
    method public androidx.compose.runtime.snapshots.SnapshotApplyResult apply();
    method public boolean getReadOnly();
    method public androidx.compose.runtime.snapshots.Snapshot getRoot();
    method public boolean hasPendingChanges();
    method public androidx.compose.runtime.snapshots.MutableSnapshot takeNestedMutableSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver);
    method public androidx.compose.runtime.snapshots.Snapshot takeNestedSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    property public boolean readOnly;
    property public androidx.compose.runtime.snapshots.Snapshot root;
  }

  public fun interface ObserverHandle {
    method public void dispose();
  }

  public abstract sealed class Snapshot {
    method public void dispose();
    method public final inline <T> T enter(kotlin.jvm.functions.Function0<? extends T> block);
    method @Deprecated public int getId();
    method public abstract boolean getReadOnly();
    method public abstract androidx.compose.runtime.snapshots.Snapshot getRoot();
    method public long getSnapshotId();
    method public abstract boolean hasPendingChanges();
    method public abstract androidx.compose.runtime.snapshots.Snapshot takeNestedSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    method public final androidx.compose.runtime.snapshots.Snapshot? unsafeEnter();
    method public final void unsafeLeave(androidx.compose.runtime.snapshots.Snapshot? oldSnapshot);
    property @Deprecated public int id;
    property public abstract boolean readOnly;
    property public abstract androidx.compose.runtime.snapshots.Snapshot root;
    property public long snapshotId;
    field public static final androidx.compose.runtime.snapshots.Snapshot.Companion Companion;
    field public static final int PreexistingSnapshotId = 1; // 0x1
  }

  public static final class Snapshot.Companion {
    method public androidx.compose.runtime.snapshots.Snapshot getCurrent();
    method public inline <T> T global(kotlin.jvm.functions.Function0<? extends T> block);
    method public boolean isApplyObserverNotificationPending();
    method public boolean isInSnapshot();
    method public void notifyObjectsInitialized();
    method public <T> T observe(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver, kotlin.jvm.functions.Function0<? extends T> block);
    method @SuppressCompatibility @androidx.compose.runtime.InternalComposeApi public int openSnapshotCount();
    method public androidx.compose.runtime.snapshots.ObserverHandle registerApplyObserver(kotlin.jvm.functions.Function2<? super java.util.Set<?>,? super androidx.compose.runtime.snapshots.Snapshot,kotlin.Unit> observer);
    method public androidx.compose.runtime.snapshots.ObserverHandle registerGlobalWriteObserver(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit> observer);
    method public void sendApplyNotifications();
    method public androidx.compose.runtime.snapshots.MutableSnapshot takeMutableSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver);
    method public androidx.compose.runtime.snapshots.Snapshot takeSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    method public inline <R> R withMutableSnapshot(kotlin.jvm.functions.Function0<? extends R> block);
    method public inline <T> T withoutReadObservation(kotlin.jvm.functions.Function0<? extends T> block);
    property public static int PreexistingSnapshotId;
    property public androidx.compose.runtime.snapshots.Snapshot current;
    property public boolean isApplyObserverNotificationPending;
    property public boolean isInSnapshot;
  }

  public final class SnapshotApplyConflictException extends java.lang.Exception {
    ctor public SnapshotApplyConflictException(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public androidx.compose.runtime.snapshots.Snapshot getSnapshot();
    property public androidx.compose.runtime.snapshots.Snapshot snapshot;
  }

  public abstract sealed class SnapshotApplyResult {
    method public abstract void check();
    method public abstract boolean getSucceeded();
    property public abstract boolean succeeded;
  }

  public static final class SnapshotApplyResult.Failure extends androidx.compose.runtime.snapshots.SnapshotApplyResult {
    ctor public SnapshotApplyResult.Failure(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void check();
    method public androidx.compose.runtime.snapshots.Snapshot getSnapshot();
    method public boolean getSucceeded();
    property public androidx.compose.runtime.snapshots.Snapshot snapshot;
    property public boolean succeeded;
  }

  public static final class SnapshotApplyResult.Success extends androidx.compose.runtime.snapshots.SnapshotApplyResult {
    method public void check();
    method public boolean getSucceeded();
    property public boolean succeeded;
    field public static final androidx.compose.runtime.snapshots.SnapshotApplyResult.Success INSTANCE;
  }

  public interface SnapshotContextElement extends kotlin.coroutines.CoroutineContext.Element {
    field public static final androidx.compose.runtime.snapshots.SnapshotContextElement.Key Key;
  }

  public static final class SnapshotContextElement.Key implements kotlin.coroutines.CoroutineContext.Key<androidx.compose.runtime.snapshots.SnapshotContextElement> {
  }

  public final class SnapshotContextElementKt {
    method public static androidx.compose.runtime.snapshots.SnapshotContextElement asContextElement(androidx.compose.runtime.snapshots.Snapshot);
  }

  public final class SnapshotId_jvmKt {
    method public static inline int toInt(long);
    method public static inline long toLong(long);
  }

  public final class SnapshotKt {
    method public static <T extends androidx.compose.runtime.snapshots.StateRecord> T readable(T, androidx.compose.runtime.snapshots.StateObject state);
    method public static <T extends androidx.compose.runtime.snapshots.StateRecord> T readable(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R withCurrent(T, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R writable(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R writable(T, androidx.compose.runtime.snapshots.StateObject state, kotlin.jvm.functions.Function1<? super T,? extends R> block);
  }

  public interface SnapshotMutableState<T> extends androidx.compose.runtime.MutableState<T> {
    method public androidx.compose.runtime.SnapshotMutationPolicy<T> getPolicy();
    property public abstract androidx.compose.runtime.SnapshotMutationPolicy<T> policy;
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateList<T> implements kotlin.jvm.internal.markers.KMutableList java.util.List<T> android.os.Parcelable java.util.RandomAccess androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateList();
    method public void add(int index, T element);
    method public boolean add(T element);
    method public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public void clear();
    method public boolean contains(T element);
    method public boolean containsAll(java.util.Collection<? extends T> elements);
    method public int describeContents();
    method public T get(int index);
    method public androidx.compose.runtime.snapshots.StateRecord getFirstStateRecord();
    method public int getSize();
    method public int indexOf(T element);
    method public boolean isEmpty();
    method public java.util.Iterator<T> iterator();
    method public int lastIndexOf(T element);
    method public java.util.ListIterator<T> listIterator();
    method public java.util.ListIterator<T> listIterator(int index);
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method @BytecodeOnly public T! remove(int);
    method public boolean remove(T element);
    method public boolean removeAll(java.util.Collection<? extends T> elements);
    method public T removeAt(int index);
    method public void removeRange(int fromIndex, int toIndex);
    method public boolean retainAll(java.util.Collection<? extends T> elements);
    method public T set(int index, T element);
    method @BytecodeOnly public int size();
    method public java.util.List<T> subList(int fromIndex, int toIndex);
    method @BytecodeOnly public Object![]! toArray();
    method @BytecodeOnly public <T> T![]! toArray(T![]!);
    method public java.util.List<T> toList();
    method public void writeToParcel(android.os.Parcel parcel, int flags);
    property public androidx.compose.runtime.snapshots.StateRecord firstStateRecord;
    property public int size;
    field public static final android.os.Parcelable.Creator<androidx.compose.runtime.snapshots.SnapshotStateList<java.lang.Object?>> CREATOR;
  }

  public final class SnapshotStateListKt {
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> SnapshotStateList(int size, kotlin.jvm.functions.Function1<? super java.lang.Integer,? extends T> init);
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateMap<K, V> implements kotlin.jvm.internal.markers.KMutableMap java.util.Map<K,V> androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateMap();
    method public void clear();
    method public boolean containsKey(K key);
    method public boolean containsValue(V value);
    method @BytecodeOnly public java.util.Set<java.util.Map.Entry<K!,V!>!>! entrySet();
    method public V? get(K key);
    method public java.util.Set<java.util.Map.Entry<K,V>> getEntries();
    method public androidx.compose.runtime.snapshots.StateRecord getFirstStateRecord();
    method public java.util.Set<K> getKeys();
    method public int getSize();
    method public java.util.Collection<V> getValues();
    method public boolean isEmpty();
    method @BytecodeOnly public java.util.Set<K!>! keySet();
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method public V? put(K key, V value);
    method public void putAll(java.util.Map<? extends K,? extends V> from);
    method public V? remove(K key);
    method @BytecodeOnly public int size();
    method public java.util.Map<K,V> toMap();
    method @BytecodeOnly public java.util.Collection<V!>! values();
    property public java.util.Set<java.util.Map.Entry<K,V>> entries;
    property public androidx.compose.runtime.snapshots.StateRecord firstStateRecord;
    property public java.util.Set<K> keys;
    property public int size;
    property public java.util.Collection<V> values;
  }

  public final class SnapshotStateObserver {
    ctor public SnapshotStateObserver(kotlin.jvm.functions.Function1<? super kotlin.jvm.functions.Function0<kotlin.Unit>,kotlin.Unit> onChangedExecutor);
    method public void clear();
    method public void clear(Object scope);
    method public void clearIf(kotlin.jvm.functions.Function1<java.lang.Object,java.lang.Boolean> predicate);
    method @org.jetbrains.annotations.TestOnly public void notifyChanges(java.util.Set<?> changes, androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public <T> void observeReads(T scope, kotlin.jvm.functions.Function1<? super T,kotlin.Unit> onValueChangedForScope, kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method public void start();
    method public void stop();
    method @Deprecated public void withNoObservations(kotlin.jvm.functions.Function0<kotlin.Unit> block);
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateSet<T> implements kotlin.jvm.internal.markers.KMutableSet android.os.Parcelable java.util.RandomAccess java.util.Set<T> androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateSet();
    method public boolean add(T element);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public void clear();
    method public boolean contains(T element);
    method public boolean containsAll(java.util.Collection<? extends T> elements);
    method public int describeContents();
    method public androidx.compose.runtime.snapshots.StateRecord getFirstStateRecord();
    method public int getSize();
    method public boolean isEmpty();
    method public java.util.Iterator<T> iterator();
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method public boolean remove(T element);
    method public boolean removeAll(java.util.Collection<? extends T> elements);
    method public boolean retainAll(java.util.Collection<? extends T> elements);
    method @BytecodeOnly public int size();
    method @BytecodeOnly public Object![]! toArray();
    method @BytecodeOnly public <T> T![]! toArray(T![]!);
    method public java.util.Set<T> toSet();
    method public void writeToParcel(android.os.Parcel parcel, int flags);
    property public androidx.compose.runtime.snapshots.StateRecord firstStateRecord;
    property public int size;
    field public static final android.os.Parcelable.Creator<androidx.compose.runtime.snapshots.SnapshotStateSet<java.lang.Object?>> CREATOR;
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.FUNCTION) public @interface StateFactoryMarker {
  }

  @kotlin.jvm.JvmDefaultWithCompatibility public interface StateObject {
    method public androidx.compose.runtime.snapshots.StateRecord getFirstStateRecord();
    method public default androidx.compose.runtime.snapshots.StateRecord? mergeRecords(androidx.compose.runtime.snapshots.StateRecord previous, androidx.compose.runtime.snapshots.StateRecord current, androidx.compose.runtime.snapshots.StateRecord applied);
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    property public abstract androidx.compose.runtime.snapshots.StateRecord firstStateRecord;
  }

  public abstract class StateRecord {
    ctor public StateRecord();
    ctor @Deprecated public StateRecord(int id);
    ctor public StateRecord(long snapshotId);
    method public abstract void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public abstract androidx.compose.runtime.snapshots.StateRecord create();
    method @BytecodeOnly @Deprecated public androidx.compose.runtime.snapshots.StateRecord! create(int);
    method public androidx.compose.runtime.snapshots.StateRecord create(long snapshotId);
  }

  public typealias SnapshotId = long;

  public typealias SnapshotIdArray = long[];

}

package androidx.compose.runtime.snapshots.tooling {

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public final class SnapshotInstanceObservers {
    ctor public SnapshotInstanceObservers();
    ctor public SnapshotInstanceObservers(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver);
    method public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? getReadObserver();
    method public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? getWriteObserver();
    property public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver;
    property public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver;
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public interface SnapshotObserver {
    method public default void onApplied(androidx.compose.runtime.snapshots.Snapshot snapshot, java.util.Set<?> changed);
    method public default void onCreated(androidx.compose.runtime.snapshots.Snapshot snapshot, androidx.compose.runtime.snapshots.Snapshot? parent, androidx.compose.runtime.snapshots.tooling.SnapshotInstanceObservers? observers);
    method public default androidx.compose.runtime.snapshots.tooling.SnapshotInstanceObservers? onPreCreate(androidx.compose.runtime.snapshots.Snapshot? parent, boolean readonly);
    method public default void onPreDispose(androidx.compose.runtime.snapshots.Snapshot snapshot);
  }

  public final class SnapshotObserverKt {
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public static androidx.compose.runtime.snapshots.ObserverHandle observeSnapshots(androidx.compose.runtime.snapshots.Snapshot.Companion, androidx.compose.runtime.snapshots.tooling.SnapshotObserver snapshotObserver);
  }

}

package androidx.compose.runtime.tooling {

  @SuppressCompatibility @kotlin.RequiresOptIn(message="This API is for tooling only and is likely to change in the future.") @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface ComposeToolingApi {
  }

  public interface CompositionData {
    method public default androidx.compose.runtime.tooling.CompositionGroup? find(Object identityToFind);
    method public Iterable<androidx.compose.runtime.tooling.CompositionGroup> getCompositionGroups();
    method public boolean isEmpty();
    property public abstract Iterable<androidx.compose.runtime.tooling.CompositionGroup> compositionGroups;
    property public abstract boolean isEmpty;
  }

  public final class CompositionDataKt {
    method public static androidx.compose.runtime.tooling.CompositionInstance? findCompositionInstance(androidx.compose.runtime.tooling.CompositionData);
  }

  public sealed interface CompositionErrorContext {
    method public boolean attachComposeStackTrace(Throwable, Object composeNode);
  }

  public final class CompositionErrorContextKt {
    method public static androidx.compose.runtime.CompositionLocal<androidx.compose.runtime.tooling.CompositionErrorContext?> getLocalCompositionErrorContext();
    property public static androidx.compose.runtime.CompositionLocal<androidx.compose.runtime.tooling.CompositionErrorContext?> LocalCompositionErrorContext;
  }

  @kotlin.jvm.JvmDefaultWithCompatibility public interface CompositionGroup extends androidx.compose.runtime.tooling.CompositionData {
    method public Iterable<java.lang.Object?> getData();
    method public default int getGroupSize();
    method public default Object? getIdentity();
    method public Object getKey();
    method public Object? getNode();
    method public default int getSlotsSize();
    method public String? getSourceInfo();
    property public abstract Iterable<java.lang.Object?> data;
    property public default int groupSize;
    property public default Object? identity;
    property public abstract Object key;
    property public abstract Object? node;
    property public default int slotsSize;
    property public abstract String? sourceInfo;
  }

  public interface CompositionInstance {
    method public androidx.compose.runtime.tooling.CompositionGroup? findContextGroup();
    method public androidx.compose.runtime.tooling.CompositionData getData();
    method public androidx.compose.runtime.tooling.CompositionInstance? getParent();
    property public abstract androidx.compose.runtime.tooling.CompositionData data;
    property public abstract androidx.compose.runtime.tooling.CompositionInstance? parent;
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public interface CompositionObserver {
    method public void onBeginComposition(androidx.compose.runtime.tooling.ObservableComposition composition);
    method public void onEndComposition(androidx.compose.runtime.tooling.ObservableComposition composition);
    method public void onReadInScope(androidx.compose.runtime.RecomposeScope scope, Object value);
    method public void onScopeDisposed(androidx.compose.runtime.RecomposeScope scope);
    method public void onScopeEnter(androidx.compose.runtime.RecomposeScope scope);
    method public void onScopeExit(androidx.compose.runtime.RecomposeScope scope);
    method public void onScopeInvalidated(androidx.compose.runtime.RecomposeScope scope, Object? value);
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public interface CompositionObserverHandle {
    method public void dispose();
  }

  public final class CompositionObserverKt {
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public static androidx.compose.runtime.tooling.CompositionObserverHandle observe(androidx.compose.runtime.Recomposer, androidx.compose.runtime.tooling.CompositionRegistrationObserver observer);
    method @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public static androidx.compose.runtime.tooling.CompositionObserverHandle? setObserver(androidx.compose.runtime.Composition, androidx.compose.runtime.tooling.CompositionObserver observer);
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public interface CompositionRegistrationObserver {
    method public void onCompositionRegistered(androidx.compose.runtime.tooling.ObservableComposition composition);
    method public void onCompositionUnregistered(androidx.compose.runtime.tooling.ObservableComposition composition);
  }

  @SuppressCompatibility @androidx.compose.runtime.tooling.ComposeToolingApi public interface IdentifiableRecomposeScope {
    method public Object? getIdentity();
    property public abstract Object? identity;
  }

  public final class InspectionTablesKt {
    method public static androidx.compose.runtime.ProvidableCompositionLocal<java.util.Set<androidx.compose.runtime.tooling.CompositionData>?> getLocalInspectionTables();
    property public static androidx.compose.runtime.ProvidableCompositionLocal<java.util.Set<androidx.compose.runtime.tooling.CompositionData>?> LocalInspectionTables;
  }

  @SuppressCompatibility @androidx.compose.runtime.tooling.ComposeToolingApi public final class LocationSourceInformation {
    ctor public LocationSourceInformation(int lineNumber, int offset, int length, boolean isRepeatable);
    method public int getLength();
    method public int getLineNumber();
    method public int getOffset();
    method public boolean isRepeatable();
    property public boolean isRepeatable;
    property public int length;
    property public int lineNumber;
    property public int offset;
  }

  @SuppressCompatibility @androidx.compose.runtime.ExperimentalComposeRuntimeApi public interface ObservableComposition {
    method public androidx.compose.runtime.tooling.CompositionObserverHandle setObserver(androidx.compose.runtime.tooling.CompositionObserver observer);
  }

  @SuppressCompatibility @androidx.compose.runtime.tooling.ComposeToolingApi public final class ParameterSourceInformation {
    ctor public ParameterSourceInformation(int sortedIndex, optional String? name, optional String? inlineClass);
    method public String? getInlineClass();
    method public String? getName();
    method public int getSortedIndex();
    property public String? inlineClass;
    property public String? name;
    property public int sortedIndex;
  }

  @SuppressCompatibility @androidx.compose.runtime.tooling.ComposeToolingApi public final class SourceInformation {
    ctor public SourceInformation(boolean isCall, boolean isInline, String? functionName, String? sourceFile, java.util.List<androidx.compose.runtime.tooling.ParameterSourceInformation> parameters, String? packageHash, java.util.List<androidx.compose.runtime.tooling.LocationSourceInformation> locations, String rawData);
    method public String? getFunctionName();
    method public java.util.List<androidx.compose.runtime.tooling.LocationSourceInformation> getLocations();
    method public String? getPackageHash();
    method public java.util.List<androidx.compose.runtime.tooling.ParameterSourceInformation> getParameters();
    method public String getRawData();
    method public String? getSourceFile();
    method public boolean isCall();
    method public boolean isInline();
    property public String? functionName;
    property public boolean isCall;
    property public boolean isInline;
    property public java.util.List<androidx.compose.runtime.tooling.LocationSourceInformation> locations;
    property public String? packageHash;
    property public java.util.List<androidx.compose.runtime.tooling.ParameterSourceInformation> parameters;
    property public String rawData;
    property public String? sourceFile;
  }

  public final class SourceInformationKt {
    method @SuppressCompatibility @androidx.compose.runtime.tooling.ComposeToolingApi public static androidx.compose.runtime.tooling.SourceInformation? parseSourceInformation(String data);
  }

}


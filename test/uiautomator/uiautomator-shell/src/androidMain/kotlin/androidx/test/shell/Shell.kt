/*
 * Copyright 2025 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.test.shell

import androidx.test.shell.internal.randomHexString
import java.io.InputStream
import java.nio.charset.Charset
import kotlin.math.ceil

/**
 * Represents an Android shell on which it's possible to run blocking commands in sequence.
 *
 * The output for each command is returned as [CommandOutput] and contains both stdout and stderr
 * for the launched command. Internally it uses a long living instance of [ShellProcess] to ensure
 * efficient performance. While [ShellProcess] offers direct access to stdin, stdout and stderr of
 * the shell process, this class offers an abstraction that focuses on serially executing, blocking
 * commands and it's appropriate for most of the usages when interacting with shell.
 *
 * Example:
 * ```kotlin
 * val foo = Shell.create().use {
 *     it.command("echo foo").stdOut.asString()
 * }
 * ```
 */
public class Shell private constructor(private val shellProcess: ShellProcess) : AutoCloseable {

    public companion object {

        /**
         * Creates a new [Shell] with the given [ShellProcess].
         *
         * @param shellProcess a shell process to use to back this [Shell].
         * @return a new [Shell] backed by the given [ShellProcess].
         */
        @JvmStatic
        @JvmOverloads
        public fun create(shellProcess: ShellProcess = ShellProcess.create()): Shell =
            Shell(shellProcess)
    }

    private val syncObj = Any()

    /**
     * Runs a command on the terminal, making sure to capture the entire output for stdout and
     * stderr of a command.
     *
     * This internally is achieved printing on stdout and stderr delimiters for begin and end of the
     * command. If the command string contains multiple shell command, for example `echo 1; echo 2;
     * echo 3` the stdout string without contains 3 lines with those numbers. If the command starts
     * several jobs or processes with a non-blocking command, some of the output may be captured in
     * the returned [CommandOutput] or in future ones. This specific behavior is unsupported and is
     * consistent with the uiautomation api [android.app.UiAutomation.executeShellCommand]. The max
     * supported command length is between 128Kb and 2Mb depending on the Android version. When the
     * command exceeds the max length, this immediately fails and the error will be reported in
     * stderr.
     *
     * @param command a string with the command to execute in this [Shell].
     * @return a [CommandOutput] with the stdout and stderr generated by running the command.
     */
    public fun command(command: String): CommandOutput =
        synchronized(syncObj) {
            if (isClosed()) throw IllegalStateException("Cannot run any command after closing.")

            // Create the delimiters
            val randomString = randomHexString(4)
            val startDelimiter = """_start${randomString}_"""
            val endDelimiter = """_end${randomString}_"""

            // The idea of these stream collector is to read on this thread, since this is a
            // blocking operation.
            val stdOutStreamCollector =
                OutputStreamCollector(
                    streamName = "stdOut",
                    input = shellProcess.stdOut,
                    startDelimiter = startDelimiter,
                    endDelimiter = endDelimiter,
                )
            val stdErrStreamCollector =
                OutputStreamCollector(
                    streamName = "stdErr",
                    input = shellProcess.stdErr,
                    startDelimiter = startDelimiter,
                    endDelimiter = endDelimiter,
                )

            // Write a start delimiter in stdout and stderr
            shellProcess.writeLine("""echo "$startDelimiter" """)
            shellProcess.writeLine("""echo "$startDelimiter" >&2 """)

            // Runs the command
            shellProcess.writeLine(command)

            // Write a end delimiter in stdout and stderr
            shellProcess.writeLine("""echo "$endDelimiter" """)
            shellProcess.writeLine("""echo "$endDelimiter" >&2 """)

            // Reads from each stream until they're both complete.
            while (stdOutStreamCollector.isAvailable() || stdErrStreamCollector.isAvailable()) {
                with(stdOutStreamCollector) { if (isAvailable()) readByte() }
                with(stdErrStreamCollector) { if (isAvailable()) readByte() }
            }

            return@synchronized CommandOutput(
                rawStdOut = stdOutStreamCollector.output(),
                rawStdErr = stdErrStreamCollector.output(),
            )
        }

    /** Stops this terminal. */
    override fun close(): Unit = synchronized(syncObj) { shellProcess.close() }

    /** Returns whether this terminal is closed. */
    public fun isClosed(): Boolean = shellProcess.isClosed()

    /** Contains the stdout and stderr output of a command executed with [Shell.command]. */
    public class CommandOutput(private val rawStdOut: ByteArray, private val rawStdErr: ByteArray) {

        public val stdOut: StdOutput = StdOutput(rawStdOut)
        public val stdErr: StdOutput = StdOutput(rawStdErr)

        /** Contains either stdout or stderr for the executed command. */
        public inner class StdOutput
        internal constructor(

            /** This process standard stream output as a byte array. */
            public val bytes: ByteArray
        ) {

            /**
             * This process standard stream as a UTF_8 string.
             *
             * @param charset The charset to use when converting the bytes read for the stream.
             * @return a string with the bytes converted using the given [charset].
             */
            @JvmOverloads
            public fun text(charset: Charset = Charsets.UTF_8): String =
                if (bytes.isEmpty()) "" else bytes.toString(charset)
        }
    }
}

/**
 * Handles collecting a stdout or stderr stream out of the process after launching a command with
 * [Shell.command]. It also takes care of cleaning the output of the command from the delimiters
 * injected to separate the streams from other commands.
 */
private class OutputStreamCollector(
    private val streamName: String,
    private val input: InputStream,
    private val startDelimiter: String,
    private val endDelimiter: String,
    private val bufferSize: Int = 1024,
) {

    companion object {
        private const val CAPACITY_GROW_RATE = 2.0f
    }

    private var lineBeginPtr = 0
    private var writePtr = 0
    private var startPtr = -1
    private var endPtr = -1
    private var buffer = ByteArray(bufferSize)

    private var complete = false

    fun isAvailable() = !complete

    fun output(): ByteArray = buffer

    fun readByte() {

        if (complete) return

        // Check if it's the end of stream. If yes, mark as complete
        if (input.available() < 0) {
            complete = true
            cleanBufferFromDelimiters()
            return
        }

        // Check if there is any data available. If not, retry later.
        if (input.available() == 0) {
            return
        }

        // Before reading the byte, we make sure the buffer is large enough for this read.
        if (writePtr >= buffer.size - 1) {

            if (buffer.size == Int.MAX_VALUE)
                throw OutOfMemoryError(
                    "$streamName of process is larger than max allowed size of ${Int.MAX_VALUE}."
                )

            // Otherwise grow the new buffer size
            var newSize = ceil(buffer.size * CAPACITY_GROW_RATE).toInt()

            // This is in case of overflow
            if (newSize < 0) newSize = Int.MAX_VALUE

            buffer = buffer.copyOf(newSize)
        }

        val byte = input.read()

        // This is a bit of an odd case where basically the underlying source
        // was closed between checking how many bytes are available and actually reading.
        // Since we control the source, it should never happen... but just in case.
        if (byte == -1) {
            complete = true
            cleanBufferFromDelimiters()
            return
        }

        // Store this byte in the buffer
        buffer[writePtr] = byte.toByte()

        // Check if this is a line terminator
        if (byte.toChar() == '\n') {

            val line = String(buffer, lineBeginPtr, writePtr - lineBeginPtr).trim()

            // Check if this is the start delimiter.
            // We don't collect the bytes if the start delimiter hasn't been found.
            if (line == startDelimiter) {
                startPtr = writePtr + 1
            }

            // Check if this is the stop delimiter.
            // If this is an end delimiter, then we can stop here.
            if (line == endDelimiter) {
                endPtr = lineBeginPtr - 1
                complete = true
                cleanBufferFromDelimiters()
            }

            // The new pointer for begin line is current write + 1 to skip this new line.
            lineBeginPtr = writePtr + 1
        }

        // Move the pointer for writing forward
        writePtr++
    }

    private fun cleanBufferFromDelimiters() {

        // If both pointers were set we can cut beginning and end.
        if (startPtr != -1 && endPtr != -1) {
            buffer = buffer.copyOfRange(startPtr, endPtr.coerceAtLeast(startPtr))
            return
        }

        // If only the start delimiter was set
        if (startPtr != -1) {
            buffer = buffer.copyOfRange(startPtr, bufferSize - startPtr)
        }
    }
}

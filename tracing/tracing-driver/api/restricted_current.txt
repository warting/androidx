// Signature format: 4.0
package androidx.tracing.driver {

  public final class ClockSource_androidKt {
    method public static inline long nanoTime();
  }

  public final class CommonKt {
    method @kotlin.PublishedApi internal static long monotonicId();
  }

  public final class ContextElementsKt {
    method @kotlin.PublishedApi internal static suspend Object? obtainPlatformThreadContextElement(kotlin.coroutines.Continuation<? super androidx.tracing.driver.PlatformThreadContextElement<? extends java.lang.Object?>?>);
  }

  public final class ContextElements_androidKt {
    method @kotlin.PublishedApi internal static androidx.tracing.driver.PlatformThreadContextElement<kotlin.Unit> buildThreadContextElement(String name, java.util.List<java.lang.Long> flowIds, kotlin.jvm.functions.Function1<? super kotlin.coroutines.CoroutineContext,kotlin.Unit> updateThreadContextBlock, kotlin.jvm.functions.Function1<? super kotlin.coroutines.CoroutineContext,kotlin.Unit> restoreThreadContextBlock);
  }

  public class CounterTrack extends androidx.tracing.driver.Track {
    ctor public CounterTrack(String name, androidx.tracing.driver.Track parent);
    method public final void setCounter(double value);
    method public final void setCounter(long value);
  }

  public final class MetadataEntry {
    method public void reset();
    property public boolean booleanValue;
    property public double doubleValue;
    property public long longValue;
    property public String? name;
    property public String stringValue;
    property public int type;
    field public boolean booleanValue;
    field public double doubleValue;
    field public long longValue;
    field public String? name;
    field public String stringValue;
    field public int type;
  }

  @kotlin.PublishedApi internal abstract class PlatformThreadContextElement<S> extends kotlin.coroutines.AbstractCoroutineContextElement {
    method public java.util.List<java.lang.Long> getFlowIds();
    method public String getName();
    method @BytecodeOnly @kotlin.PublishedApi internal final java.util.concurrent.atomic.AtomicInteger getStarted();
    method @kotlin.PublishedApi internal abstract void restoreThreadContext(kotlin.coroutines.CoroutineContext context, S oldState);
    method @kotlin.PublishedApi internal abstract S updateThreadContext(kotlin.coroutines.CoroutineContext context);
    property public java.util.List<java.lang.Long> flowIds;
    property public String name;
    property @kotlin.PublishedApi internal final java.util.concurrent.atomic.AtomicInteger started;
    field @kotlin.PublishedApi internal static final kotlin.coroutines.CoroutineContext.Key<androidx.tracing.driver.PlatformThreadContextElement<? extends java.lang.Object?>> KEY;
    field @kotlin.PublishedApi internal static final int STATE_BEGIN = 1; // 0x1
    field @kotlin.PublishedApi internal static final int STATE_END = 0; // 0x0
    field @kotlin.PublishedApi internal final java.util.concurrent.atomic.AtomicInteger started;
  }

  @kotlin.PublishedApi internal static final class PlatformThreadContextElement.Companion {
    method @BytecodeOnly @kotlin.PublishedApi internal kotlin.coroutines.CoroutineContext.Key<androidx.tracing.driver.PlatformThreadContextElement<? extends java.lang.Object!>!> getKEY();
    property @kotlin.PublishedApi internal kotlin.coroutines.CoroutineContext.Key<androidx.tracing.driver.PlatformThreadContextElement<? extends java.lang.Object?>> KEY;
    property @kotlin.PublishedApi internal static int STATE_BEGIN;
    property @kotlin.PublishedApi internal static int STATE_END;
  }

  public abstract class Poolable<T extends androidx.tracing.driver.Poolable<T>> {
    method public abstract void recycle();
  }

  public final class PooledTracePacketArray extends androidx.tracing.driver.Poolable<androidx.tracing.driver.PooledTracePacketArray> {
    method public inline void forEach(kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEvent,kotlin.Unit> block);
    method public void recycle();
    property public int fillCount;
    property public androidx.tracing.driver.TraceEvent[] packets;
    field public int fillCount;
    field public final androidx.tracing.driver.TraceEvent[] packets;
  }

  public class ProcessTrack extends androidx.tracing.driver.SliceTrack {
    ctor public ProcessTrack(androidx.tracing.driver.TraceContext context, int id, String name);
    method public androidx.tracing.driver.CounterTrack getOrCreateCounterTrack(String name);
    method public androidx.tracing.driver.ThreadTrack getOrCreateThreadTrack(int id, String name);
  }

  @kotlin.PublishedApi internal final class ProtoPool {
    ctor public ProtoPool(boolean isDebug);
    method public androidx.tracing.driver.PooledTracePacketArray obtainTracePacketArray();
    method public long poolableCount();
  }

  public abstract class SliceTrack extends androidx.tracing.driver.Track {
    ctor public SliceTrack(androidx.tracing.driver.TraceContext context, long uuid);
    method public final inline void beginSection(String name);
    method public final inline void beginSection(String name, java.util.List<java.lang.Long> flowIds);
    method public final inline void beginSection(String name, java.util.List<java.lang.Long> flowIds, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock);
    method public final inline void beginSection(String name, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock);
    method public final inline void endSection();
    method @BytecodeOnly @kotlin.PublishedApi internal final Object getPacketLock();
    method public final void instant(String name);
    method public final inline <T> T trace(String name, kotlin.jvm.functions.Function0<? extends T> block);
    method public final inline <T> T trace(String name, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock, kotlin.jvm.functions.Function0<? extends T> block);
    method public final suspend inline <T> Object? traceCoroutine(String name, kotlin.jvm.functions.Function1<? super kotlin.coroutines.Continuation<? super T>,? extends java.lang.Object?> block, optional kotlin.coroutines.Continuation<? super T>);
    method public final suspend inline <T> Object? traceCoroutine(String name, optional long flowId, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock, kotlin.jvm.functions.Function1<? super kotlin.coroutines.Continuation<? super T>,? extends java.lang.Object?> block, kotlin.coroutines.Continuation<? super T>);
    method public final suspend inline <T> Object? traceCoroutine(String name, optional long flowId, kotlin.jvm.functions.Function1<? super kotlin.coroutines.Continuation<? super T>,? extends java.lang.Object?> block, kotlin.coroutines.Continuation<? super T>);
    property @kotlin.PublishedApi internal final Object packetLock;
    field @kotlin.PublishedApi internal final Object packetLock;
  }

  public class ThreadTrack extends androidx.tracing.driver.SliceTrack {
    ctor public ThreadTrack(int id, String name, androidx.tracing.driver.ProcessTrack process);
  }

  public class TraceContext implements java.lang.AutoCloseable {
    ctor public TraceContext(androidx.tracing.driver.TraceSink sink, boolean isEnabled);
    method public void close();
    method public final void flush();
    method public androidx.tracing.driver.ProcessTrack getOrCreateProcessTrack(int id, String name);
    method public final androidx.tracing.driver.TraceSink getSink();
    method public final boolean isEnabled();
    property public final boolean isEnabled;
    property public final androidx.tracing.driver.TraceSink sink;
  }

  public final class TraceDriver {
    ctor public TraceDriver(androidx.tracing.driver.TraceSink sink, optional boolean isEnabled);
    method public androidx.tracing.driver.ProcessTrack ProcessTrack(int id, String name);
    method public androidx.tracing.driver.TraceContext getContext();
    property public androidx.tracing.driver.TraceContext context;
  }

  public final class TraceEvent {
    ctor public TraceEvent();
    method public void reset();
    method @kotlin.PublishedApi internal inline void setBeginSection(long trackUuid, String name);
    method @kotlin.PublishedApi internal inline void setBeginSectionWithFlows(long trackUuid, String name, java.util.List<java.lang.Long> flowIds);
    method @kotlin.PublishedApi internal inline void setCounterDouble(long trackUuid, double value);
    method @kotlin.PublishedApi internal inline void setCounterLong(long trackUuid, long value);
    method @kotlin.PublishedApi internal inline void setEndSection(long trackUuid);
    method @kotlin.PublishedApi internal inline void setInstant(long trackUuid, String name);
    property public Double? counterDoubleValue;
    property public Long? counterLongValue;
    property public java.util.List<java.lang.Long> flowIds;
    property public java.util.List<androidx.tracing.driver.MetadataEntry> metadataEntries;
    property public int metadataEntryIndex;
    property public String? name;
    property public long timestamp;
    property public androidx.tracing.driver.TrackDescriptor? trackDescriptor;
    property public long trackUuid;
    property public int type;
    field public Double? counterDoubleValue;
    field public Long? counterLongValue;
    field public java.util.List<java.lang.Long> flowIds;
    field public java.util.List<androidx.tracing.driver.MetadataEntry> metadataEntries;
    field public int metadataEntryIndex;
    field public String? name;
    field public long timestamp;
    field public androidx.tracing.driver.TrackDescriptor? trackDescriptor;
    field public long trackUuid;
    field public int type;
  }

  public final class TraceEventKt {
    property @kotlin.PublishedApi internal static int TRACE_EVENT_TYPE_BEGIN;
    property @kotlin.PublishedApi internal static int TRACE_EVENT_TYPE_COUNTER;
    property @kotlin.PublishedApi internal static int TRACE_EVENT_TYPE_END;
    property @kotlin.PublishedApi internal static int TRACE_EVENT_TYPE_INSTANT;
    property @kotlin.PublishedApi internal static int TRACE_EVENT_TYPE_UNDEFINED;
    field @kotlin.PublishedApi internal static final int TRACE_EVENT_TYPE_BEGIN = 1; // 0x1
    field @kotlin.PublishedApi internal static final int TRACE_EVENT_TYPE_COUNTER = 4; // 0x4
    field @kotlin.PublishedApi internal static final int TRACE_EVENT_TYPE_END = 2; // 0x2
    field @kotlin.PublishedApi internal static final int TRACE_EVENT_TYPE_INSTANT = 3; // 0x3
    field @kotlin.PublishedApi internal static final int TRACE_EVENT_TYPE_UNDEFINED = 0; // 0x0
  }

  @kotlin.jvm.JvmInline public final value class TraceEventScope {
    ctor @KotlinOnly @kotlin.PublishedApi internal TraceEventScope(androidx.tracing.driver.TraceEvent event);
    method @KotlinOnly public void addMetadataEntry(String name, boolean value);
    method @KotlinOnly public void addMetadataEntry(String name, double value);
    method @KotlinOnly public void addMetadataEntry(String name, String value);
    method @KotlinOnly public void addMetadataEntry(String name, long value);
    method @BytecodeOnly public static void addMetadataEntry-impl(androidx.tracing.driver.TraceEvent!, String, boolean);
    method @BytecodeOnly public static void addMetadataEntry-impl(androidx.tracing.driver.TraceEvent!, String, double);
    method @BytecodeOnly public static void addMetadataEntry-impl(androidx.tracing.driver.TraceEvent!, String, String);
    method @BytecodeOnly public static void addMetadataEntry-impl(androidx.tracing.driver.TraceEvent!, String, long);
    method @BytecodeOnly public static androidx.tracing.driver.TraceEventScope! box-impl(androidx.tracing.driver.TraceEvent!);
    method @BytecodeOnly @kotlin.PublishedApi internal static androidx.tracing.driver.TraceEvent constructor-impl(androidx.tracing.driver.TraceEvent);
    method @BytecodeOnly public androidx.tracing.driver.TraceEvent! unbox-impl();
  }

  public abstract class TraceSink implements java.lang.AutoCloseable {
    ctor public TraceSink();
    method public abstract void close();
    method public abstract void enqueue(androidx.tracing.driver.PooledTracePacketArray pooledPacketArray);
    method public abstract void flush();
  }

  public final class Tracing_androidKt {
    method public static androidx.tracing.driver.ProcessTrack currentProcessTrack(android.content.Context context, androidx.tracing.driver.TraceDriver traceDriver);
  }

  public abstract class Track {
    ctor public Track(@kotlin.PublishedApi androidx.tracing.driver.TraceContext context, @kotlin.PublishedApi long uuid);
    method @kotlin.PublishedApi internal final inline void emitTraceEvent(optional boolean immediateDispatch, kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEvent,kotlin.Unit> block);
    method @kotlin.PublishedApi internal final void flush();
    method @BytecodeOnly @kotlin.PublishedApi internal final androidx.tracing.driver.ProtoPool getPool();
    property @kotlin.PublishedApi internal final androidx.tracing.driver.TraceContext context;
    property @kotlin.PublishedApi internal final androidx.tracing.driver.PooledTracePacketArray currentPacketArray;
    property @kotlin.PublishedApi internal final int currentPacketArraySize;
    property @kotlin.PublishedApi internal final androidx.tracing.driver.ProtoPool pool;
    property @kotlin.PublishedApi internal final long uuid;
    field @kotlin.PublishedApi internal androidx.tracing.driver.PooledTracePacketArray currentPacketArray;
    field @kotlin.PublishedApi internal int currentPacketArraySize;
    field @kotlin.PublishedApi internal final androidx.tracing.driver.ProtoPool pool;
  }

  public final class TrackDescriptor {
    ctor public TrackDescriptor(String name, long uuid, long parentUuid, int type, int pid, int tid);
    method public String getName();
    method public long getParentUuid();
    method public int getPid();
    method public int getTid();
    method public int getType();
    method public long getUuid();
    method public void setName(String);
    method public void setParentUuid(long);
    method public void setPid(int);
    method public void setTid(int);
    method public void setType(int);
    method public void setUuid(long);
    property public String name;
    property public long parentUuid;
    property public int pid;
    property public int tid;
    property public int type;
    property public long uuid;
  }

  public typealias AtomicBoolean = java.util.concurrent.atomic.AtomicBoolean;

  public typealias AtomicInteger = java.util.concurrent.atomic.AtomicInteger;

  public typealias AtomicLong = java.util.concurrent.atomic.AtomicLong;

}


// Signature format: 4.0
package androidx.xr.runtime {

  public final class AugmentedObjectCategory {
    method public static java.util.List<androidx.xr.runtime.AugmentedObjectCategory> all();
    field public static final androidx.xr.runtime.AugmentedObjectCategory.Companion Companion;
    field public static final androidx.xr.runtime.AugmentedObjectCategory KEYBOARD;
    field public static final androidx.xr.runtime.AugmentedObjectCategory LAPTOP;
    field public static final androidx.xr.runtime.AugmentedObjectCategory MOUSE;
    field public static final androidx.xr.runtime.AugmentedObjectCategory UNKNOWN;
  }

  public static final class AugmentedObjectCategory.Companion {
    method public java.util.List<androidx.xr.runtime.AugmentedObjectCategory> all();
    property public androidx.xr.runtime.AugmentedObjectCategory KEYBOARD;
    property public androidx.xr.runtime.AugmentedObjectCategory LAPTOP;
    property public androidx.xr.runtime.AugmentedObjectCategory MOUSE;
    property public androidx.xr.runtime.AugmentedObjectCategory UNKNOWN;
  }

  public final class Config {
    ctor public Config();
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Config();
    ctor public Config(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking);
    ctor public Config(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking);
    ctor public Config(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.HeadTrackingMode headTracking);
    ctor public Config(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.HeadTrackingMode headTracking, optional androidx.xr.runtime.Config.DepthEstimationMode depthEstimation);
    ctor public Config(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.HeadTrackingMode headTracking, optional androidx.xr.runtime.Config.DepthEstimationMode depthEstimation, optional androidx.xr.runtime.Config.AnchorPersistenceMode anchorPersistence);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Config(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional java.util.List<androidx.xr.runtime.AugmentedObjectCategory> augmentedObjectCategories, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.DeviceTrackingMode deviceTracking, optional androidx.xr.runtime.Config.DepthEstimationMode depthEstimation, optional androidx.xr.runtime.Config.AnchorPersistenceMode anchorPersistence, optional androidx.xr.runtime.Config.FaceTrackingMode faceTracking, optional androidx.xr.runtime.Config.GeospatialMode geospatial);
    method public androidx.xr.runtime.Config copy();
    method public androidx.xr.runtime.Config copy(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking);
    method public androidx.xr.runtime.Config copy(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config copy(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.DeviceTrackingMode deviceTracking, optional androidx.xr.runtime.Config.DepthEstimationMode depthEstimation, optional androidx.xr.runtime.Config.AnchorPersistenceMode anchorPersistence, optional androidx.xr.runtime.Config.FaceTrackingMode faceTracking, optional androidx.xr.runtime.Config.GeospatialMode geospatial, optional java.util.List<androidx.xr.runtime.AugmentedObjectCategory> augmentedObjectCategories);
    method public androidx.xr.runtime.Config copy(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.HeadTrackingMode headTracking);
    method public androidx.xr.runtime.Config copy(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.HeadTrackingMode headTracking, optional androidx.xr.runtime.Config.DepthEstimationMode depthEstimation);
    method public androidx.xr.runtime.Config copy(optional androidx.xr.runtime.Config.PlaneTrackingMode planeTracking, optional androidx.xr.runtime.Config.HandTrackingMode handTracking, optional androidx.xr.runtime.Config.HeadTrackingMode headTracking, optional androidx.xr.runtime.Config.DepthEstimationMode depthEstimation, optional androidx.xr.runtime.Config.AnchorPersistenceMode anchorPersistence);
    method public androidx.xr.runtime.Config.AnchorPersistenceMode getAnchorPersistence();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.AugmentedObjectCategory> getAugmentedObjectCategories();
    method public androidx.xr.runtime.Config.DepthEstimationMode getDepthEstimation();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.DeviceTrackingMode getDeviceTracking();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.FaceTrackingMode getFaceTracking();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.GeospatialMode getGeospatial();
    method public androidx.xr.runtime.Config.HandTrackingMode getHandTracking();
    method public androidx.xr.runtime.Config.HeadTrackingMode getHeadTracking();
    method public androidx.xr.runtime.Config.PlaneTrackingMode getPlaneTracking();
    property public androidx.xr.runtime.Config.AnchorPersistenceMode anchorPersistence;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.AugmentedObjectCategory> augmentedObjectCategories;
    property public androidx.xr.runtime.Config.DepthEstimationMode depthEstimation;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.DeviceTrackingMode deviceTracking;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.FaceTrackingMode faceTracking;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.GeospatialMode geospatial;
    property public androidx.xr.runtime.Config.HandTrackingMode handTracking;
    property public androidx.xr.runtime.Config.HeadTrackingMode headTracking;
    property public androidx.xr.runtime.Config.PlaneTrackingMode planeTracking;
  }

  public static final class Config.AnchorPersistenceMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.AnchorPersistenceMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.AnchorPersistenceMode DISABLED;
    field public static final androidx.xr.runtime.Config.AnchorPersistenceMode LOCAL;
  }

  public static final class Config.AnchorPersistenceMode.Companion {
    property public androidx.xr.runtime.Config.AnchorPersistenceMode DISABLED;
    property public androidx.xr.runtime.Config.AnchorPersistenceMode LOCAL;
  }

  public static final class Config.DepthEstimationMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.DepthEstimationMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.DepthEstimationMode DISABLED;
    field public static final androidx.xr.runtime.Config.DepthEstimationMode RAW_ONLY;
    field public static final androidx.xr.runtime.Config.DepthEstimationMode SMOOTH_AND_RAW;
    field public static final androidx.xr.runtime.Config.DepthEstimationMode SMOOTH_ONLY;
  }

  public static final class Config.DepthEstimationMode.Companion {
    property public androidx.xr.runtime.Config.DepthEstimationMode DISABLED;
    property public androidx.xr.runtime.Config.DepthEstimationMode RAW_ONLY;
    property public androidx.xr.runtime.Config.DepthEstimationMode SMOOTH_AND_RAW;
    property public androidx.xr.runtime.Config.DepthEstimationMode SMOOTH_ONLY;
  }

  public static final class Config.DeviceTrackingMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.HeadTrackingMode toHeadTrackingMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.DeviceTrackingMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.DeviceTrackingMode DISABLED;
    field public static final androidx.xr.runtime.Config.DeviceTrackingMode LAST_KNOWN;
  }

  public static final class Config.DeviceTrackingMode.Companion {
    property public androidx.xr.runtime.Config.DeviceTrackingMode DISABLED;
    property public androidx.xr.runtime.Config.DeviceTrackingMode LAST_KNOWN;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static final class Config.FaceTrackingMode {
    method public int getMode();
    property public int mode;
    field public static final androidx.xr.runtime.Config.FaceTrackingMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.FaceTrackingMode DISABLED;
    field public static final androidx.xr.runtime.Config.FaceTrackingMode USER;
  }

  public static final class Config.FaceTrackingMode.Companion {
    property public androidx.xr.runtime.Config.FaceTrackingMode DISABLED;
    property public androidx.xr.runtime.Config.FaceTrackingMode USER;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static final class Config.GeospatialMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.GeospatialMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.GeospatialMode DISABLED;
    field public static final androidx.xr.runtime.Config.GeospatialMode EARTH;
  }

  public static final class Config.GeospatialMode.Companion {
    property public androidx.xr.runtime.Config.GeospatialMode DISABLED;
    property public androidx.xr.runtime.Config.GeospatialMode EARTH;
  }

  public static final class Config.HandTrackingMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.HandTrackingMode BOTH;
    field public static final androidx.xr.runtime.Config.HandTrackingMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.HandTrackingMode DISABLED;
  }

  public static final class Config.HandTrackingMode.Companion {
    property public androidx.xr.runtime.Config.HandTrackingMode BOTH;
    property public androidx.xr.runtime.Config.HandTrackingMode DISABLED;
  }

  public static final class Config.HeadTrackingMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.Config.DeviceTrackingMode toDeviceTrackingMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.HeadTrackingMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.HeadTrackingMode DISABLED;
    field public static final androidx.xr.runtime.Config.HeadTrackingMode LAST_KNOWN;
  }

  public static final class Config.HeadTrackingMode.Companion {
    property public androidx.xr.runtime.Config.HeadTrackingMode DISABLED;
    property public androidx.xr.runtime.Config.HeadTrackingMode LAST_KNOWN;
  }

  public static final class Config.PlaneTrackingMode {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int getMode();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public int mode;
    field public static final androidx.xr.runtime.Config.PlaneTrackingMode.Companion Companion;
    field public static final androidx.xr.runtime.Config.PlaneTrackingMode DISABLED;
    field public static final androidx.xr.runtime.Config.PlaneTrackingMode HORIZONTAL_AND_VERTICAL;
  }

  public static final class Config.PlaneTrackingMode.Companion {
    property public androidx.xr.runtime.Config.PlaneTrackingMode DISABLED;
    property public androidx.xr.runtime.Config.PlaneTrackingMode HORIZONTAL_AND_VERTICAL;
  }

  public final class CoreState {
    ctor public CoreState(kotlin.time.ComparableTimeMark timeMark);
    method public kotlin.time.ComparableTimeMark getTimeMark();
    property public kotlin.time.ComparableTimeMark timeMark;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FieldOfView {
    ctor public FieldOfView(float angleLeft, float angleRight, float angleUp, float angleDown);
    method public androidx.xr.runtime.FieldOfView copy();
    method public androidx.xr.runtime.FieldOfView copy(optional float angleLeft);
    method public androidx.xr.runtime.FieldOfView copy(optional float angleLeft, optional float angleRight);
    method public androidx.xr.runtime.FieldOfView copy(optional float angleLeft, optional float angleRight, optional float angleUp);
    method public androidx.xr.runtime.FieldOfView copy(optional float angleLeft, optional float angleRight, optional float angleUp, optional float angleDown);
    method public float getAngleDown();
    method public float getAngleLeft();
    method public float getAngleRight();
    method public float getAngleUp();
    property public float angleDown;
    property public float angleLeft;
    property public float angleRight;
    property public float angleUp;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class NodeHolder<T> extends androidx.xr.runtime.TypeHolder<T> {
    ctor public NodeHolder(T node, Class<? extends java.lang.Object?> type);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class RequiredCalibrationType {
    field public static final androidx.xr.runtime.RequiredCalibrationType.Companion Companion;
    field public static final androidx.xr.runtime.RequiredCalibrationType FACE_TRACKING;
  }

  public static final class RequiredCalibrationType.Companion {
    property public androidx.xr.runtime.RequiredCalibrationType FACE_TRACKING;
  }

  public final class Session {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Session(android.app.Activity activity);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Session(android.app.Activity activity, optional java.util.List<? extends androidx.xr.runtime.StateExtender> stateExtenders);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Session(android.app.Activity activity, optional java.util.List<? extends androidx.xr.runtime.StateExtender> stateExtenders, optional java.util.List<? extends androidx.xr.runtime.SessionConnector> sessionConnectors);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Session(android.app.Activity activity, optional java.util.List<? extends androidx.xr.runtime.StateExtender> stateExtenders, optional java.util.List<? extends androidx.xr.runtime.SessionConnector> sessionConnectors, optional java.util.List<? extends androidx.xr.runtime.internal.JxrRuntime> runtimes);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Session(android.app.Activity activity, optional java.util.List<? extends androidx.xr.runtime.StateExtender> stateExtenders, optional java.util.List<? extends androidx.xr.runtime.SessionConnector> sessionConnectors, optional java.util.List<? extends androidx.xr.runtime.internal.JxrRuntime> runtimes, optional kotlinx.coroutines.CoroutineScope coroutineScope);
    method public androidx.xr.runtime.SessionConfigureResult configure(androidx.xr.runtime.Config config);
    method public static androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity);
    method public static androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, androidx.lifecycle.LifecycleOwner lifecycleOwner);
    method public static androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, androidx.lifecycle.LifecycleOwner lifecycleOwner, optional kotlin.coroutines.CoroutineContext coroutineContext);
    method public static androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, optional kotlin.coroutines.CoroutineContext coroutineContext);
    method @Deprecated @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, optional kotlin.coroutines.CoroutineContext coroutineContext, optional boolean unscaledGravityAlignedActivitySpace);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public android.app.Activity getActivity();
    method public androidx.xr.runtime.Config getConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public kotlinx.coroutines.CoroutineScope getCoroutineScope();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.internal.JxrRuntime> getRuntimes();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.SessionConnector> getSessionConnectors();
    method public kotlinx.coroutines.flow.StateFlow<androidx.xr.runtime.CoreState> getState();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.StateExtender> getStateExtenders();
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public android.app.Activity activity;
    property public androidx.xr.runtime.Config config;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public kotlinx.coroutines.CoroutineScope coroutineScope;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.internal.JxrRuntime> runtimes;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.SessionConnector> sessionConnectors;
    property public kotlinx.coroutines.flow.StateFlow<androidx.xr.runtime.CoreState> state;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.runtime.StateExtender> stateExtenders;
    field public static final androidx.xr.runtime.Session.Companion Companion;
  }

  public static final class Session.Companion {
    method public androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity);
    method public androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, androidx.lifecycle.LifecycleOwner lifecycleOwner);
    method public androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, androidx.lifecycle.LifecycleOwner lifecycleOwner, optional kotlin.coroutines.CoroutineContext coroutineContext);
    method public androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, optional kotlin.coroutines.CoroutineContext coroutineContext);
    method @Deprecated @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.SessionCreateResult create(android.app.Activity activity, optional kotlin.coroutines.CoroutineContext coroutineContext, optional boolean unscaledGravityAlignedActivitySpace);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class SessionConfigureCalibrationRequired extends androidx.xr.runtime.SessionConfigureResult {
    ctor public SessionConfigureCalibrationRequired(androidx.xr.runtime.RequiredCalibrationType calibrationType);
    method public androidx.xr.runtime.RequiredCalibrationType getCalibrationType();
    property public androidx.xr.runtime.RequiredCalibrationType calibrationType;
  }

  public final class SessionConfigureConfigurationNotSupported extends androidx.xr.runtime.SessionConfigureResult {
    ctor public SessionConfigureConfigurationNotSupported();
  }

  public final class SessionConfigureGooglePlayServicesLocationLibraryNotLinked extends androidx.xr.runtime.SessionConfigureResult {
    ctor public SessionConfigureGooglePlayServicesLocationLibraryNotLinked();
  }

  public abstract sealed class SessionConfigureResult {
  }

  public final class SessionConfigureSuccess extends androidx.xr.runtime.SessionConfigureResult {
    ctor public SessionConfigureSuccess();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface SessionConnector {
    method public void close();
    method public void initialize(java.util.List<? extends androidx.xr.runtime.internal.JxrRuntime> runtimes);
  }

  public final class SessionCreateApkRequired extends androidx.xr.runtime.SessionCreateResult {
    ctor public SessionCreateApkRequired(String requiredApk);
    method public String getRequiredApk();
    property public String requiredApk;
  }

  public abstract sealed class SessionCreateResult {
  }

  public final class SessionCreateSuccess extends androidx.xr.runtime.SessionCreateResult {
    ctor public SessionCreateSuccess(androidx.xr.runtime.Session session);
    method public androidx.xr.runtime.Session getSession();
    property public androidx.xr.runtime.Session session;
  }

  public final class SessionCreateUnsupportedDevice extends androidx.xr.runtime.SessionCreateResult {
    ctor public SessionCreateUnsupportedDevice();
  }

  public abstract sealed class SessionResumeResult {
  }

  public final class SessionResumeSuccess extends androidx.xr.runtime.SessionResumeResult {
    ctor public SessionResumeSuccess();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class SpatialStateHolder<T> extends androidx.xr.runtime.TypeHolder<T> {
    ctor public SpatialStateHolder(T state, Class<? extends java.lang.Object?> type);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface StateExtender {
    method public suspend Object? extend(androidx.xr.runtime.CoreState coreState, kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method public void initialize(java.util.List<? extends androidx.xr.runtime.internal.JxrRuntime> runtimes);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class SubspaceNodeHolder<T> extends androidx.xr.runtime.TypeHolder<T> {
    ctor public SubspaceNodeHolder(T subspaceNode, Class<? extends java.lang.Object?> type);
  }

  public final class TrackingState {
    field public static final androidx.xr.runtime.TrackingState.Companion Companion;
    field public static final androidx.xr.runtime.TrackingState PAUSED;
    field public static final androidx.xr.runtime.TrackingState STOPPED;
    field public static final androidx.xr.runtime.TrackingState TRACKING;
  }

  public static final class TrackingState.Companion {
    property public androidx.xr.runtime.TrackingState PAUSED;
    property public androidx.xr.runtime.TrackingState STOPPED;
    property public androidx.xr.runtime.TrackingState TRACKING;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public abstract sealed class TypeHolder<T> {
    method public static final <T> androidx.xr.runtime.TypeHolder<T> assertCast(androidx.xr.runtime.TypeHolder<? extends java.lang.Object?> anyTypeHolder, Class<T> targetType);
    method public static final <T> T assertGetValue(androidx.xr.runtime.TypeHolder<? extends java.lang.Object?> anyTypeHolder, Class<T> targetType);
    method public final Class<? extends java.lang.Object?> getType();
    method public final T getValue();
    method public static final <T, U extends androidx.xr.runtime.TypeHolder<T>> U? safeCast(androidx.xr.runtime.TypeHolder<? extends java.lang.Object?> anyTypeHolder, Class<T> targetType);
    property public final Class<? extends java.lang.Object?> type;
    property public final T value;
    field public static final androidx.xr.runtime.TypeHolder.Companion Companion;
  }

  public static final class TypeHolder.Companion {
    method public <T> androidx.xr.runtime.TypeHolder<T> assertCast(androidx.xr.runtime.TypeHolder<? extends java.lang.Object?> anyTypeHolder, Class<T> targetType);
    method public <T> T assertGetValue(androidx.xr.runtime.TypeHolder<? extends java.lang.Object?> anyTypeHolder, Class<T> targetType);
    method public <T, U extends androidx.xr.runtime.TypeHolder<T>> U? safeCast(androidx.xr.runtime.TypeHolder<? extends java.lang.Object?> anyTypeHolder, Class<T> targetType);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class VpsAvailabilityAvailable extends androidx.xr.runtime.VpsAvailabilityResult {
    ctor public VpsAvailabilityAvailable();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class VpsAvailabilityErrorInternal extends androidx.xr.runtime.VpsAvailabilityResult {
    ctor public VpsAvailabilityErrorInternal();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class VpsAvailabilityNetworkError extends androidx.xr.runtime.VpsAvailabilityResult {
    ctor public VpsAvailabilityNetworkError();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class VpsAvailabilityNotAuthorized extends androidx.xr.runtime.VpsAvailabilityResult {
    ctor public VpsAvailabilityNotAuthorized();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class VpsAvailabilityResourceExhausted extends androidx.xr.runtime.VpsAvailabilityResult {
    ctor public VpsAvailabilityResourceExhausted();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public abstract sealed class VpsAvailabilityResult {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class VpsAvailabilityUnavailable extends androidx.xr.runtime.VpsAvailabilityResult {
    ctor public VpsAvailabilityUnavailable();
  }

}

package androidx.xr.runtime.internal {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ApkCheckAvailabilityErrorException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public ApkCheckAvailabilityErrorException(String requiredApk);
    method public String getRequiredApk();
    property public String requiredApk;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ApkCheckAvailabilityInProgressException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public ApkCheckAvailabilityInProgressException(String requiredApk);
    method public String getRequiredApk();
    property public String requiredApk;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ApkNotInstalledException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public ApkNotInstalledException(String requiredApk);
    method public String getRequiredApk();
    property public String requiredApk;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ConfigurationNotSupportedException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public ConfigurationNotSupportedException();
    ctor public ConfigurationNotSupportedException(optional String message, optional Throwable? cause);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FaceTrackingNotCalibratedException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public FaceTrackingNotCalibratedException();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class Feature {
    field public static final androidx.xr.runtime.internal.Feature.Companion Companion;
    field public static final androidx.xr.runtime.internal.Feature FULLSTACK;
    field public static final androidx.xr.runtime.internal.Feature OPEN_XR;
    field public static final androidx.xr.runtime.internal.Feature PROJECTED;
    field public static final androidx.xr.runtime.internal.Feature SPATIAL;
  }

  public static final class Feature.Companion {
    property public androidx.xr.runtime.internal.Feature FULLSTACK;
    property public androidx.xr.runtime.internal.Feature OPEN_XR;
    property public androidx.xr.runtime.internal.Feature PROJECTED;
    property public androidx.xr.runtime.internal.Feature SPATIAL;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class GooglePlayServicesLocationLibraryNotLinkedException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public GooglePlayServicesLocationLibraryNotLinkedException();
    ctor public GooglePlayServicesLocationLibraryNotLinkedException(optional Throwable? cause);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface JxrPlatformAdapterFactory extends androidx.xr.runtime.internal.Service {
    method public androidx.xr.runtime.internal.JxrRuntime createPlatformAdapter(android.app.Activity activity, optional boolean unscaledGravityAlignedActivitySpace);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface JxrRuntime {
    method public default void configure(androidx.xr.runtime.Config config);
    method public default void destroy();
    method public default void initialize();
    method public default void pause();
    method public default void resume();
    method public default suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark?>);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public class LifecycleException extends java.lang.Exception {
    ctor public LifecycleException(String message, optional Throwable? cause);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface LifecycleManager {
    method public void configure(androidx.xr.runtime.Config config);
    method public void create();
    method public androidx.xr.runtime.Config getConfig();
    method public void pause();
    method public void resume();
    method public void stop();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark>);
    property public abstract androidx.xr.runtime.Config config;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface PerceptionRuntimeFactory extends androidx.xr.runtime.internal.Service {
    method public androidx.xr.runtime.internal.JxrRuntime createRuntime(android.app.Activity activity, kotlin.coroutines.CoroutineContext coroutineContext);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface RenderingFeature {
    method public void dispose();
    method public androidx.xr.runtime.NodeHolder<? extends java.lang.Object?> getNodeHolder();
    property public abstract androidx.xr.runtime.NodeHolder<? extends java.lang.Object?> nodeHolder;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface RenderingRuntimeFactory extends androidx.xr.runtime.internal.Service {
    method public androidx.xr.runtime.internal.JxrRuntime create(java.util.List<? extends androidx.xr.runtime.internal.JxrRuntime> runtimes, android.app.Activity activity);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface SceneRuntimeFactory extends androidx.xr.runtime.internal.Service {
    method public androidx.xr.runtime.internal.JxrRuntime create(android.app.Activity activity);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface Service {
    method public java.util.Set<androidx.xr.runtime.internal.Feature> getRequirements();
    property public abstract java.util.Set<androidx.xr.runtime.internal.Feature> requirements;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class UnsupportedDeviceException extends androidx.xr.runtime.internal.LifecycleException {
    ctor public UnsupportedDeviceException();
  }

}

package androidx.xr.runtime.math {

  public final class BoundingBox {
    ctor public BoundingBox(androidx.xr.runtime.math.Vector3 min, androidx.xr.runtime.math.Vector3 max);
    method public androidx.xr.runtime.math.Vector3 getMax();
    method public androidx.xr.runtime.math.Vector3 getMin();
    property public androidx.xr.runtime.math.Vector3 max;
    property public androidx.xr.runtime.math.Vector3 min;
  }

  public final class FloatSize2d {
    ctor public FloatSize2d();
    ctor public FloatSize2d(optional float width, optional float height);
    method public operator androidx.xr.runtime.math.FloatSize2d div(float divisor);
    method public operator androidx.xr.runtime.math.FloatSize2d div(int divisor);
    method public float getHeight();
    method public float getWidth();
    method public operator androidx.xr.runtime.math.FloatSize2d times(float scalar);
    method public operator androidx.xr.runtime.math.FloatSize2d times(int scalar);
    method public androidx.xr.runtime.math.FloatSize3d to3d(optional float depth);
    property public float height;
    property public float width;
  }

  public final class FloatSize3d {
    ctor public FloatSize3d();
    ctor public FloatSize3d(optional float width, optional float height, optional float depth);
    method public operator androidx.xr.runtime.math.FloatSize3d div(float divisor);
    method public operator androidx.xr.runtime.math.FloatSize3d div(int divisor);
    method public float getDepth();
    method public float getHeight();
    method public float getWidth();
    method public operator androidx.xr.runtime.math.FloatSize3d times(float scalar);
    method public operator androidx.xr.runtime.math.FloatSize3d times(int scalar);
    method public androidx.xr.runtime.math.FloatSize2d to2d();
    property public float depth;
    property public float height;
    property public float width;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class GeospatialPose {
    ctor public GeospatialPose();
    ctor public GeospatialPose(optional double latitude, optional double longitude, optional double altitude, optional androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion);
    method public double getAltitude();
    method public androidx.xr.runtime.math.Quaternion getEastUpSouthQuaternion();
    method public double getLatitude();
    method public double getLongitude();
    property public double altitude;
    property public androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion;
    property public double latitude;
    property public double longitude;
  }

  public final class IntSize2d {
    ctor public IntSize2d();
    ctor public IntSize2d(optional int width, optional int height);
    method public int getHeight();
    method public int getWidth();
    property public int height;
    property public int width;
  }

  public final class MathHelper {
    method public static float clamp(float x, float min, float max);
    method public static float lerp(float a, float b, float t);
    method public static float toDegrees(float angleInRadians);
    method public static float toRadians(float angleInDegrees);
  }

  public final class Matrix3 {
    ctor public Matrix3(androidx.xr.runtime.math.Matrix3 other);
    ctor public Matrix3(float[] dataToCopy);
    method public androidx.xr.runtime.math.Matrix3 copy(optional float[] data);
    method public static androidx.xr.runtime.math.Matrix3 fromQuaternion(androidx.xr.runtime.math.Quaternion quaternion);
    method public static androidx.xr.runtime.math.Matrix3 fromScale(androidx.xr.runtime.math.Vector3 scale);
    method public static androidx.xr.runtime.math.Matrix3 fromScale(float scale);
    method public float[] getData();
    method public androidx.xr.runtime.math.Matrix3 getInverse();
    method public androidx.xr.runtime.math.Quaternion getRotation();
    method public androidx.xr.runtime.math.Vector3 getScale();
    method public androidx.xr.runtime.math.Matrix3 getTranspose();
    method public boolean isTrs();
    method public operator androidx.xr.runtime.math.Matrix3 times(androidx.xr.runtime.math.Matrix3 other);
    property public float[] data;
    property public androidx.xr.runtime.math.Matrix3 inverse;
    property public boolean isTrs;
    property public androidx.xr.runtime.math.Quaternion rotation;
    property public androidx.xr.runtime.math.Vector3 scale;
    property public androidx.xr.runtime.math.Matrix3 transpose;
    field public static final androidx.xr.runtime.math.Matrix3.Companion Companion;
    field public static final androidx.xr.runtime.math.Matrix3 IDENTITY;
    field public static final androidx.xr.runtime.math.Matrix3 ZERO;
  }

  public static final class Matrix3.Companion {
    method public androidx.xr.runtime.math.Matrix3 fromQuaternion(androidx.xr.runtime.math.Quaternion quaternion);
    method public androidx.xr.runtime.math.Matrix3 fromScale(androidx.xr.runtime.math.Vector3 scale);
    method public androidx.xr.runtime.math.Matrix3 fromScale(float scale);
    property public androidx.xr.runtime.math.Matrix3 IDENTITY;
    property public androidx.xr.runtime.math.Matrix3 ZERO;
  }

  public final class Matrix4 {
    ctor public Matrix4(androidx.xr.runtime.math.Matrix4 other);
    ctor public Matrix4(float[] dataToCopy);
    method public androidx.xr.runtime.math.Matrix4 copy(optional float[] data);
    method public static androidx.xr.runtime.math.Matrix4 fromPose(androidx.xr.runtime.math.Pose pose);
    method public static androidx.xr.runtime.math.Matrix4 fromQuaternion(androidx.xr.runtime.math.Quaternion quaternion);
    method public static androidx.xr.runtime.math.Matrix4 fromScale(androidx.xr.runtime.math.Vector3 scale);
    method public static androidx.xr.runtime.math.Matrix4 fromScale(float scale);
    method public static androidx.xr.runtime.math.Matrix4 fromTranslation(androidx.xr.runtime.math.Vector3 translation);
    method public static androidx.xr.runtime.math.Matrix4 fromTrs(androidx.xr.runtime.math.Vector3 translation, androidx.xr.runtime.math.Quaternion rotation, androidx.xr.runtime.math.Vector3 scale);
    method public float[] getData();
    method public androidx.xr.runtime.math.Matrix4 getInverse();
    method public androidx.xr.runtime.math.Pose getPose();
    method public androidx.xr.runtime.math.Quaternion getRotation();
    method public androidx.xr.runtime.math.Vector3 getScale();
    method public androidx.xr.runtime.math.Vector3 getTranslation();
    method public androidx.xr.runtime.math.Matrix4 getTranspose();
    method public boolean isTrs();
    method public operator androidx.xr.runtime.math.Matrix4 times(androidx.xr.runtime.math.Matrix4 other);
    method public androidx.xr.runtime.math.Matrix4 unscaled();
    property public float[] data;
    property public androidx.xr.runtime.math.Matrix4 inverse;
    property public boolean isTrs;
    property public androidx.xr.runtime.math.Pose pose;
    property public androidx.xr.runtime.math.Quaternion rotation;
    property public androidx.xr.runtime.math.Vector3 scale;
    property public androidx.xr.runtime.math.Vector3 translation;
    property public androidx.xr.runtime.math.Matrix4 transpose;
    field public static final androidx.xr.runtime.math.Matrix4.Companion Companion;
    field public static final androidx.xr.runtime.math.Matrix4 Identity;
    field public static final androidx.xr.runtime.math.Matrix4 Zero;
  }

  public static final class Matrix4.Companion {
    method public androidx.xr.runtime.math.Matrix4 fromPose(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.runtime.math.Matrix4 fromQuaternion(androidx.xr.runtime.math.Quaternion quaternion);
    method public androidx.xr.runtime.math.Matrix4 fromScale(androidx.xr.runtime.math.Vector3 scale);
    method public androidx.xr.runtime.math.Matrix4 fromScale(float scale);
    method public androidx.xr.runtime.math.Matrix4 fromTranslation(androidx.xr.runtime.math.Vector3 translation);
    method public androidx.xr.runtime.math.Matrix4 fromTrs(androidx.xr.runtime.math.Vector3 translation, androidx.xr.runtime.math.Quaternion rotation, androidx.xr.runtime.math.Vector3 scale);
    property public androidx.xr.runtime.math.Matrix4 Identity;
    property public androidx.xr.runtime.math.Matrix4 Zero;
  }

  public final class Pose {
    ctor public Pose();
    ctor public Pose(androidx.xr.runtime.math.Pose other);
    ctor public Pose(optional androidx.xr.runtime.math.Vector3 translation);
    ctor public Pose(optional androidx.xr.runtime.math.Vector3 translation, optional androidx.xr.runtime.math.Quaternion rotation);
    method public infix androidx.xr.runtime.math.Pose compose(androidx.xr.runtime.math.Pose other);
    method public androidx.xr.runtime.math.Pose copy();
    method public androidx.xr.runtime.math.Pose copy(optional androidx.xr.runtime.math.Vector3 translation);
    method public androidx.xr.runtime.math.Pose copy(optional androidx.xr.runtime.math.Vector3 translation, optional androidx.xr.runtime.math.Quaternion rotation);
    method public static float distance(androidx.xr.runtime.math.Pose lhs, androidx.xr.runtime.math.Pose rhs);
    method public static androidx.xr.runtime.math.Pose fromLookAt(androidx.xr.runtime.math.Vector3 eye, androidx.xr.runtime.math.Vector3 target);
    method public static androidx.xr.runtime.math.Pose fromLookAt(androidx.xr.runtime.math.Vector3 eye, androidx.xr.runtime.math.Vector3 target, optional androidx.xr.runtime.math.Vector3 up);
    method public inline androidx.xr.runtime.math.Vector3 getBackward();
    method public inline androidx.xr.runtime.math.Vector3 getDown();
    method public inline androidx.xr.runtime.math.Vector3 getForward();
    method public androidx.xr.runtime.math.Pose getInverse();
    method public inline androidx.xr.runtime.math.Vector3 getLeft();
    method public inline androidx.xr.runtime.math.Vector3 getRight();
    method public androidx.xr.runtime.math.Quaternion getRotation();
    method public androidx.xr.runtime.math.Vector3 getTranslation();
    method public inline androidx.xr.runtime.math.Vector3 getUp();
    method public static androidx.xr.runtime.math.Pose lerp(androidx.xr.runtime.math.Pose start, androidx.xr.runtime.math.Pose end, float ratio);
    method public androidx.xr.runtime.math.Pose rotate(androidx.xr.runtime.math.Quaternion rotation);
    method public infix androidx.xr.runtime.math.Vector3 transformPoint(androidx.xr.runtime.math.Vector3 point);
    method public infix androidx.xr.runtime.math.Vector3 transformVector(androidx.xr.runtime.math.Vector3 vector);
    method public androidx.xr.runtime.math.Pose translate(androidx.xr.runtime.math.Vector3 translation);
    property public inline androidx.xr.runtime.math.Vector3 backward;
    property public inline androidx.xr.runtime.math.Vector3 down;
    property public inline androidx.xr.runtime.math.Vector3 forward;
    property public androidx.xr.runtime.math.Pose inverse;
    property public inline androidx.xr.runtime.math.Vector3 left;
    property public inline androidx.xr.runtime.math.Vector3 right;
    property public androidx.xr.runtime.math.Quaternion rotation;
    property public androidx.xr.runtime.math.Vector3 translation;
    property public inline androidx.xr.runtime.math.Vector3 up;
    field public static final androidx.xr.runtime.math.Pose.Companion Companion;
    field public static final androidx.xr.runtime.math.Pose Identity;
  }

  public static final class Pose.Companion {
    method public float distance(androidx.xr.runtime.math.Pose lhs, androidx.xr.runtime.math.Pose rhs);
    method public androidx.xr.runtime.math.Pose fromLookAt(androidx.xr.runtime.math.Vector3 eye, androidx.xr.runtime.math.Vector3 target);
    method public androidx.xr.runtime.math.Pose fromLookAt(androidx.xr.runtime.math.Vector3 eye, androidx.xr.runtime.math.Vector3 target, optional androidx.xr.runtime.math.Vector3 up);
    method public androidx.xr.runtime.math.Pose lerp(androidx.xr.runtime.math.Pose start, androidx.xr.runtime.math.Pose end, float ratio);
    property public androidx.xr.runtime.math.Pose Identity;
  }

  public final class Quaternion {
    ctor public Quaternion();
    ctor public Quaternion(androidx.xr.runtime.math.Quaternion other);
    ctor public Quaternion(optional float x);
    ctor public Quaternion(optional float x, optional float y);
    ctor public Quaternion(optional float x, optional float y, optional float z);
    ctor public Quaternion(optional float x, optional float y, optional float z, optional float w);
    method public static float angle(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end);
    method public androidx.xr.runtime.math.Quaternion copy();
    method public androidx.xr.runtime.math.Quaternion copy(optional float x);
    method public androidx.xr.runtime.math.Quaternion copy(optional float x, optional float y);
    method public androidx.xr.runtime.math.Quaternion copy(optional float x, optional float y, optional float z);
    method public androidx.xr.runtime.math.Quaternion copy(optional float x, optional float y, optional float z, optional float w);
    method public operator androidx.xr.runtime.math.Quaternion div(float c);
    method public inline infix float dot(androidx.xr.runtime.math.Quaternion other);
    method public static float dot(androidx.xr.runtime.math.Quaternion lhs, androidx.xr.runtime.math.Quaternion rhs);
    method public static androidx.xr.runtime.math.Quaternion fromAxisAngle(androidx.xr.runtime.math.Vector3 axis, float degrees);
    method public static androidx.xr.runtime.math.Quaternion fromEulerAngles(androidx.xr.runtime.math.Vector3 eulerAngles);
    method public static androidx.xr.runtime.math.Quaternion fromEulerAngles(float pitch, float yaw, float roll);
    method public static androidx.xr.runtime.math.Quaternion fromLookTowards(androidx.xr.runtime.math.Vector3 forward, androidx.xr.runtime.math.Vector3 up);
    method public static androidx.xr.runtime.math.Quaternion fromRotation(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end);
    method public static androidx.xr.runtime.math.Quaternion fromRotation(androidx.xr.runtime.math.Vector3 start, androidx.xr.runtime.math.Vector3 end);
    method public kotlin.Pair<androidx.xr.runtime.math.Vector3,java.lang.Float> getAxisAngle();
    method public androidx.xr.runtime.math.Vector3 getEulerAngles();
    method public inline androidx.xr.runtime.math.Quaternion getInverse();
    method public float getW();
    method public float getX();
    method public float getY();
    method public float getZ();
    method public static androidx.xr.runtime.math.Quaternion lerp(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end, float ratio);
    method public inline operator androidx.xr.runtime.math.Quaternion minus(androidx.xr.runtime.math.Quaternion other);
    method public inline operator androidx.xr.runtime.math.Quaternion plus(androidx.xr.runtime.math.Quaternion other);
    method public static androidx.xr.runtime.math.Quaternion slerp(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end, float ratio);
    method public inline operator androidx.xr.runtime.math.Quaternion times(androidx.xr.runtime.math.Quaternion other);
    method public inline operator androidx.xr.runtime.math.Vector3 times(androidx.xr.runtime.math.Vector3 src);
    method public operator androidx.xr.runtime.math.Quaternion times(float c);
    method public androidx.xr.runtime.math.Quaternion toNormalized();
    method public inline operator androidx.xr.runtime.math.Quaternion unaryMinus();
    property public kotlin.Pair<androidx.xr.runtime.math.Vector3,java.lang.Float> axisAngle;
    property public androidx.xr.runtime.math.Vector3 eulerAngles;
    property public inline androidx.xr.runtime.math.Quaternion inverse;
    property public float w;
    property public float x;
    property public float y;
    property public float z;
    field public static final androidx.xr.runtime.math.Quaternion.Companion Companion;
    field public static final androidx.xr.runtime.math.Quaternion Identity;
  }

  public static final class Quaternion.Companion {
    method public float angle(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end);
    method public float dot(androidx.xr.runtime.math.Quaternion lhs, androidx.xr.runtime.math.Quaternion rhs);
    method public androidx.xr.runtime.math.Quaternion fromAxisAngle(androidx.xr.runtime.math.Vector3 axis, float degrees);
    method public androidx.xr.runtime.math.Quaternion fromEulerAngles(androidx.xr.runtime.math.Vector3 eulerAngles);
    method public androidx.xr.runtime.math.Quaternion fromEulerAngles(float pitch, float yaw, float roll);
    method public androidx.xr.runtime.math.Quaternion fromLookTowards(androidx.xr.runtime.math.Vector3 forward, androidx.xr.runtime.math.Vector3 up);
    method public androidx.xr.runtime.math.Quaternion fromRotation(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end);
    method public androidx.xr.runtime.math.Quaternion fromRotation(androidx.xr.runtime.math.Vector3 start, androidx.xr.runtime.math.Vector3 end);
    method public androidx.xr.runtime.math.Quaternion lerp(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end, float ratio);
    method public androidx.xr.runtime.math.Quaternion slerp(androidx.xr.runtime.math.Quaternion start, androidx.xr.runtime.math.Quaternion end, float ratio);
    property public androidx.xr.runtime.math.Quaternion Identity;
  }

  public final class Ray {
    ctor public Ray();
    ctor public Ray(androidx.xr.runtime.math.Ray other);
    ctor public Ray(optional androidx.xr.runtime.math.Vector3 origin, optional androidx.xr.runtime.math.Vector3 direction);
    method public androidx.xr.runtime.math.Vector3 getDirection();
    method public androidx.xr.runtime.math.Vector3 getOrigin();
    property public androidx.xr.runtime.math.Vector3 direction;
    property public androidx.xr.runtime.math.Vector3 origin;
  }

  public final class Vector2 {
    ctor public Vector2();
    ctor public Vector2(androidx.xr.runtime.math.Vector2 other);
    ctor public Vector2(optional float x);
    ctor public Vector2(optional float x, optional float y);
    method public static androidx.xr.runtime.math.Vector2 abs(androidx.xr.runtime.math.Vector2 vector);
    method public static float angularDistance(androidx.xr.runtime.math.Vector2 vector1, androidx.xr.runtime.math.Vector2 vector2);
    method public androidx.xr.runtime.math.Vector2 clamp(androidx.xr.runtime.math.Vector2 min, androidx.xr.runtime.math.Vector2 max);
    method public inline androidx.xr.runtime.math.Vector2 copy();
    method public inline androidx.xr.runtime.math.Vector2 copy(optional float x);
    method public inline androidx.xr.runtime.math.Vector2 copy(optional float x, optional float y);
    method public inline infix float cross(androidx.xr.runtime.math.Vector2 other);
    method public static float distance(androidx.xr.runtime.math.Vector2 vector1, androidx.xr.runtime.math.Vector2 vector2);
    method public inline operator androidx.xr.runtime.math.Vector2 div(float c);
    method public inline infix float dot(androidx.xr.runtime.math.Vector2 other);
    method public inline float getLength();
    method public inline float getLengthSquared();
    method public float getX();
    method public float getY();
    method public androidx.xr.runtime.math.Vector2 inverse();
    method public static androidx.xr.runtime.math.Vector2 lerp(androidx.xr.runtime.math.Vector2 start, androidx.xr.runtime.math.Vector2 end, float ratio);
    method public inline operator androidx.xr.runtime.math.Vector2 minus(androidx.xr.runtime.math.Vector2 other);
    method public operator androidx.xr.runtime.math.Vector2 plus(androidx.xr.runtime.math.Vector2 other);
    method public inline androidx.xr.runtime.math.Vector2 scale(androidx.xr.runtime.math.Vector2 other);
    method public inline operator androidx.xr.runtime.math.Vector2 times(float c);
    method public androidx.xr.runtime.math.Vector2 toNormalized();
    method public inline operator androidx.xr.runtime.math.Vector2 unaryMinus();
    property public inline float length;
    property public inline float lengthSquared;
    property public float x;
    property public float y;
    field public static final androidx.xr.runtime.math.Vector2.Companion Companion;
    field public static final androidx.xr.runtime.math.Vector2 Down;
    field public static final androidx.xr.runtime.math.Vector2 Left;
    field public static final androidx.xr.runtime.math.Vector2 One;
    field public static final androidx.xr.runtime.math.Vector2 Right;
    field public static final androidx.xr.runtime.math.Vector2 Up;
    field public static final androidx.xr.runtime.math.Vector2 Zero;
  }

  public static final class Vector2.Companion {
    method public androidx.xr.runtime.math.Vector2 abs(androidx.xr.runtime.math.Vector2 vector);
    method public float angularDistance(androidx.xr.runtime.math.Vector2 vector1, androidx.xr.runtime.math.Vector2 vector2);
    method public float distance(androidx.xr.runtime.math.Vector2 vector1, androidx.xr.runtime.math.Vector2 vector2);
    method public androidx.xr.runtime.math.Vector2 lerp(androidx.xr.runtime.math.Vector2 start, androidx.xr.runtime.math.Vector2 end, float ratio);
    property public androidx.xr.runtime.math.Vector2 Down;
    property public androidx.xr.runtime.math.Vector2 Left;
    property public androidx.xr.runtime.math.Vector2 One;
    property public androidx.xr.runtime.math.Vector2 Right;
    property public androidx.xr.runtime.math.Vector2 Up;
    property public androidx.xr.runtime.math.Vector2 Zero;
  }

  public final class Vector3 {
    ctor public Vector3();
    ctor public Vector3(androidx.xr.runtime.math.Vector3 other);
    ctor public Vector3(optional float x);
    ctor public Vector3(optional float x, optional float y);
    ctor public Vector3(optional float x, optional float y, optional float z);
    method public static androidx.xr.runtime.math.Vector3 abs(androidx.xr.runtime.math.Vector3 vector);
    method public static float angleBetween(androidx.xr.runtime.math.Vector3 vector1, androidx.xr.runtime.math.Vector3 vector2);
    method public androidx.xr.runtime.math.Vector3 clamp(androidx.xr.runtime.math.Vector3 min, androidx.xr.runtime.math.Vector3 max);
    method public androidx.xr.runtime.math.Vector3 copy();
    method public androidx.xr.runtime.math.Vector3 copy(optional float x);
    method public androidx.xr.runtime.math.Vector3 copy(optional float x, optional float y);
    method public androidx.xr.runtime.math.Vector3 copy(optional float x, optional float y, optional float z);
    method public infix androidx.xr.runtime.math.Vector3 cross(androidx.xr.runtime.math.Vector3 other);
    method public static float distance(androidx.xr.runtime.math.Vector3 vector1, androidx.xr.runtime.math.Vector3 vector2);
    method public operator androidx.xr.runtime.math.Vector3 div(float c);
    method public infix float dot(androidx.xr.runtime.math.Vector3 other);
    method public static androidx.xr.runtime.math.Vector3 fromValue(float value);
    method public inline float getLength();
    method public inline float getLengthSquared();
    method public float getX();
    method public float getY();
    method public float getZ();
    method public androidx.xr.runtime.math.Vector3 inverse();
    method public static androidx.xr.runtime.math.Vector3 lerp(androidx.xr.runtime.math.Vector3 start, androidx.xr.runtime.math.Vector3 end, float ratio);
    method public static androidx.xr.runtime.math.Vector3 max(androidx.xr.runtime.math.Vector3 a, androidx.xr.runtime.math.Vector3 b);
    method public static androidx.xr.runtime.math.Vector3 min(androidx.xr.runtime.math.Vector3 a, androidx.xr.runtime.math.Vector3 b);
    method public operator androidx.xr.runtime.math.Vector3 minus(androidx.xr.runtime.math.Vector3 other);
    method public operator androidx.xr.runtime.math.Vector3 plus(androidx.xr.runtime.math.Vector3 other);
    method public static androidx.xr.runtime.math.Vector3 projectOnPlane(androidx.xr.runtime.math.Vector3 vector, androidx.xr.runtime.math.Vector3 planeNormal);
    method public androidx.xr.runtime.math.Vector3 scale(androidx.xr.runtime.math.Vector3 other);
    method public operator androidx.xr.runtime.math.Vector3 times(float c);
    method public androidx.xr.runtime.math.Vector3 toNormalized();
    method public operator androidx.xr.runtime.math.Vector3 unaryMinus();
    property public inline float length;
    property public inline float lengthSquared;
    property public float x;
    property public float y;
    property public float z;
    field public static final androidx.xr.runtime.math.Vector3 Backward;
    field public static final androidx.xr.runtime.math.Vector3.Companion Companion;
    field public static final androidx.xr.runtime.math.Vector3 Down;
    field public static final androidx.xr.runtime.math.Vector3 Forward;
    field public static final androidx.xr.runtime.math.Vector3 Left;
    field public static final androidx.xr.runtime.math.Vector3 One;
    field public static final androidx.xr.runtime.math.Vector3 Right;
    field public static final androidx.xr.runtime.math.Vector3 Up;
    field public static final androidx.xr.runtime.math.Vector3 Zero;
  }

  public static final class Vector3.Companion {
    method public androidx.xr.runtime.math.Vector3 abs(androidx.xr.runtime.math.Vector3 vector);
    method public float angleBetween(androidx.xr.runtime.math.Vector3 vector1, androidx.xr.runtime.math.Vector3 vector2);
    method public float distance(androidx.xr.runtime.math.Vector3 vector1, androidx.xr.runtime.math.Vector3 vector2);
    method public androidx.xr.runtime.math.Vector3 fromValue(float value);
    method public androidx.xr.runtime.math.Vector3 lerp(androidx.xr.runtime.math.Vector3 start, androidx.xr.runtime.math.Vector3 end, float ratio);
    method public androidx.xr.runtime.math.Vector3 max(androidx.xr.runtime.math.Vector3 a, androidx.xr.runtime.math.Vector3 b);
    method public androidx.xr.runtime.math.Vector3 min(androidx.xr.runtime.math.Vector3 a, androidx.xr.runtime.math.Vector3 b);
    method public androidx.xr.runtime.math.Vector3 projectOnPlane(androidx.xr.runtime.math.Vector3 vector, androidx.xr.runtime.math.Vector3 planeNormal);
    property public androidx.xr.runtime.math.Vector3 Backward;
    property public androidx.xr.runtime.math.Vector3 Down;
    property public androidx.xr.runtime.math.Vector3 Forward;
    property public androidx.xr.runtime.math.Vector3 Left;
    property public androidx.xr.runtime.math.Vector3 One;
    property public androidx.xr.runtime.math.Vector3 Right;
    property public androidx.xr.runtime.math.Vector3 Up;
    property public androidx.xr.runtime.math.Vector3 Zero;
  }

  public final class Vector4 {
    ctor public Vector4();
    ctor public Vector4(androidx.xr.runtime.math.Vector4 other);
    ctor public Vector4(optional float x);
    ctor public Vector4(optional float x, optional float y);
    ctor public Vector4(optional float x, optional float y, optional float z);
    ctor public Vector4(optional float x, optional float y, optional float z, optional float w);
    method public static androidx.xr.runtime.math.Vector4 abs(androidx.xr.runtime.math.Vector4 vector);
    method public static float angleBetween(androidx.xr.runtime.math.Vector4 vector1, androidx.xr.runtime.math.Vector4 vector2);
    method public androidx.xr.runtime.math.Vector4 clamp(androidx.xr.runtime.math.Vector4 min, androidx.xr.runtime.math.Vector4 max);
    method public androidx.xr.runtime.math.Vector4 copy();
    method public androidx.xr.runtime.math.Vector4 copy(optional float x);
    method public androidx.xr.runtime.math.Vector4 copy(optional float x, optional float y);
    method public androidx.xr.runtime.math.Vector4 copy(optional float x, optional float y, optional float z);
    method public androidx.xr.runtime.math.Vector4 copy(optional float x, optional float y, optional float z, optional float w);
    method public static float distance(androidx.xr.runtime.math.Vector4 vector1, androidx.xr.runtime.math.Vector4 vector2);
    method public operator androidx.xr.runtime.math.Vector4 div(float c);
    method public infix float dot(androidx.xr.runtime.math.Vector4 other);
    method public static androidx.xr.runtime.math.Vector4 fromValue(float value);
    method public inline float getLength();
    method public inline float getLengthSquared();
    method public float getW();
    method public float getX();
    method public float getY();
    method public float getZ();
    method public androidx.xr.runtime.math.Vector4 inverse();
    method public static androidx.xr.runtime.math.Vector4 lerp(androidx.xr.runtime.math.Vector4 start, androidx.xr.runtime.math.Vector4 end, float ratio);
    method public static androidx.xr.runtime.math.Vector4 max(androidx.xr.runtime.math.Vector4 a, androidx.xr.runtime.math.Vector4 b);
    method public static androidx.xr.runtime.math.Vector4 min(androidx.xr.runtime.math.Vector4 a, androidx.xr.runtime.math.Vector4 b);
    method public operator androidx.xr.runtime.math.Vector4 minus(androidx.xr.runtime.math.Vector4 other);
    method public operator androidx.xr.runtime.math.Vector4 plus(androidx.xr.runtime.math.Vector4 other);
    method public androidx.xr.runtime.math.Vector4 scale(androidx.xr.runtime.math.Vector4 other);
    method public operator androidx.xr.runtime.math.Vector4 times(float c);
    method public androidx.xr.runtime.math.Vector4 toNormalized();
    method public operator androidx.xr.runtime.math.Vector4 unaryMinus();
    property public inline float length;
    property public inline float lengthSquared;
    property public float w;
    property public float x;
    property public float y;
    property public float z;
    field public static final androidx.xr.runtime.math.Vector4.Companion Companion;
    field public static final androidx.xr.runtime.math.Vector4 One;
    field public static final androidx.xr.runtime.math.Vector4 Zero;
  }

  public static final class Vector4.Companion {
    method public androidx.xr.runtime.math.Vector4 abs(androidx.xr.runtime.math.Vector4 vector);
    method public float angleBetween(androidx.xr.runtime.math.Vector4 vector1, androidx.xr.runtime.math.Vector4 vector2);
    method public float distance(androidx.xr.runtime.math.Vector4 vector1, androidx.xr.runtime.math.Vector4 vector2);
    method public androidx.xr.runtime.math.Vector4 fromValue(float value);
    method public androidx.xr.runtime.math.Vector4 lerp(androidx.xr.runtime.math.Vector4 start, androidx.xr.runtime.math.Vector4 end, float ratio);
    method public androidx.xr.runtime.math.Vector4 max(androidx.xr.runtime.math.Vector4 a, androidx.xr.runtime.math.Vector4 b);
    method public androidx.xr.runtime.math.Vector4 min(androidx.xr.runtime.math.Vector4 a, androidx.xr.runtime.math.Vector4 b);
    property public androidx.xr.runtime.math.Vector4 One;
    property public androidx.xr.runtime.math.Vector4 Zero;
  }

}


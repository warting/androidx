// Signature format: 4.0
package androidx.xr.runtime.testing {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public interface AnchorHolder {
    method public void detachAnchor(androidx.xr.arcore.internal.Anchor anchor);
    method public void onAnchorPersisted(androidx.xr.arcore.internal.Anchor anchor);
  }

  public final class FakeLifecycleManager implements androidx.xr.runtime.internal.LifecycleManager {
    ctor public FakeLifecycleManager();
    ctor public FakeLifecycleManager(optional boolean hasCreatePermission);
    method public void allowOneMoreCallToUpdate();
    method public void configure(androidx.xr.runtime.Config config);
    method public void create();
    method public androidx.xr.runtime.Config getConfig();
    method public androidx.xr.runtime.testing.FakeLifecycleManager.State getState();
    method public kotlin.time.TestTimeSource getTimeSource();
    method public boolean hasCreatePermission();
    method public boolean hasMissingPermission();
    method public void pause();
    method public void resume();
    method public void setConfig(androidx.xr.runtime.Config);
    method public void setHasCreatePermission(boolean);
    method public void setHasMissingPermission(boolean);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public void setShouldSupportFaceTracking(boolean);
    method public void setShouldSupportPlaneTracking(boolean);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public boolean shouldSupportFaceTracking();
    method public boolean shouldSupportPlaneTracking();
    method public void stop();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark>);
    property public androidx.xr.runtime.Config config;
    property public boolean hasCreatePermission;
    property public boolean hasMissingPermission;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public boolean shouldSupportFaceTracking;
    property public boolean shouldSupportPlaneTracking;
    property public androidx.xr.runtime.testing.FakeLifecycleManager.State state;
    property public kotlin.time.TestTimeSource timeSource;
    field public static final androidx.xr.runtime.testing.FakeLifecycleManager.Companion Companion;
    field public static final java.util.List<java.lang.String> TestPermissions;
  }

  public static final class FakeLifecycleManager.Companion {
    property public java.util.List<java.lang.String> TestPermissions;
  }

  public enum FakeLifecycleManager.State {
    enum_constant public static final androidx.xr.runtime.testing.FakeLifecycleManager.State DESTROYED;
    enum_constant public static final androidx.xr.runtime.testing.FakeLifecycleManager.State INITIALIZED;
    enum_constant public static final androidx.xr.runtime.testing.FakeLifecycleManager.State NOT_INITIALIZED;
    enum_constant public static final androidx.xr.runtime.testing.FakeLifecycleManager.State PAUSED;
    enum_constant public static final androidx.xr.runtime.testing.FakeLifecycleManager.State RESUMED;
  }

  public final class FakePerceptionManager implements androidx.xr.runtime.testing.AnchorHolder androidx.xr.arcore.internal.PerceptionManager {
    ctor public FakePerceptionManager();
    method public void addHitResult(androidx.xr.arcore.internal.HitResult hitResult);
    method public void addTrackable(androidx.xr.arcore.internal.Trackable trackable);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public suspend Object? checkVpsAvailability(double latitude, double longitude, kotlin.coroutines.Continuation<? super androidx.xr.runtime.VpsAvailabilityResult>);
    method public void clearHitResults();
    method public void clearTrackables();
    method public androidx.xr.arcore.internal.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method public void detachAnchor(androidx.xr.arcore.internal.Anchor anchor);
    method public java.util.List<androidx.xr.arcore.internal.Anchor> getAnchors();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeArDevice getArDevice();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.arcore.internal.DepthMap> getDepthMaps();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.arcore.internal.Earth getEarth();
    method public androidx.xr.arcore.internal.Hand? getLeftHand();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeRenderViewpoint? getLeftRenderViewpoint();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeRenderViewpoint? getMonoRenderViewpoint();
    method public java.util.List<java.util.UUID> getPersistedAnchorUuids();
    method public androidx.xr.arcore.internal.Hand? getRightHand();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeRenderViewpoint? getRightRenderViewpoint();
    method public java.util.List<androidx.xr.arcore.internal.Trackable> getTrackables();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.arcore.internal.Face? getUserFace();
    method public java.util.List<androidx.xr.arcore.internal.HitResult> hitTest(androidx.xr.runtime.math.Ray ray);
    method public boolean isTrackingAvailable();
    method public androidx.xr.arcore.internal.Anchor loadAnchor(java.util.UUID uuid);
    method public androidx.xr.arcore.internal.Anchor loadAnchorFromNativePointer(long nativePointer);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public void onAnchorPersisted(androidx.xr.arcore.internal.Anchor anchor);
    method public void setTrackingAvailable(boolean);
    method public void unpersistAnchor(java.util.UUID uuid);
    property public java.util.List<androidx.xr.arcore.internal.Anchor> anchors;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeArDevice arDevice;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.util.List<androidx.xr.arcore.internal.DepthMap> depthMaps;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.arcore.internal.Earth earth;
    property public boolean isTrackingAvailable;
    property public androidx.xr.arcore.internal.Hand? leftHand;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeRenderViewpoint? leftRenderViewpoint;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeRenderViewpoint? monoRenderViewpoint;
    property public androidx.xr.arcore.internal.Hand? rightHand;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.testing.FakeRuntimeRenderViewpoint? rightRenderViewpoint;
    property public java.util.List<androidx.xr.arcore.internal.Trackable> trackables;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.arcore.internal.Face? userFace;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakePerceptionRuntime implements androidx.xr.arcore.internal.PerceptionRuntime {
    ctor public FakePerceptionRuntime(androidx.xr.runtime.testing.FakeLifecycleManager lifecycleManager, androidx.xr.runtime.testing.FakePerceptionManager perceptionManager);
    method public androidx.xr.runtime.testing.FakeLifecycleManager component1();
    method public androidx.xr.runtime.testing.FakePerceptionManager component2();
    method public androidx.xr.runtime.testing.FakePerceptionRuntime copy(optional androidx.xr.runtime.testing.FakeLifecycleManager lifecycleManager, optional androidx.xr.runtime.testing.FakePerceptionManager perceptionManager);
    method public androidx.xr.runtime.testing.FakeLifecycleManager getLifecycleManager();
    method public androidx.xr.runtime.testing.FakePerceptionManager getPerceptionManager();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark?>);
    property public androidx.xr.runtime.testing.FakeLifecycleManager lifecycleManager;
    property public androidx.xr.runtime.testing.FakePerceptionManager perceptionManager;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakePerceptionRuntimeFactory implements androidx.xr.runtime.internal.PerceptionRuntimeFactory {
    ctor public FakePerceptionRuntimeFactory();
    method public androidx.xr.runtime.testing.FakePerceptionRuntime createRuntime(android.app.Activity activity);
    method public androidx.xr.runtime.testing.FakePerceptionRuntime createRuntime(android.app.Activity activity, kotlin.coroutines.CoroutineContext coroutineContext);
    method public java.util.Set<androidx.xr.runtime.internal.Feature> getRequirements();
    method public static boolean hasCreatePermission();
    method public static void setHasCreatePermission(boolean);
    property public java.util.Set<androidx.xr.runtime.internal.Feature> requirements;
    field public static final androidx.xr.runtime.testing.FakePerceptionRuntimeFactory.Companion Companion;
  }

  public static final class FakePerceptionRuntimeFactory.Companion {
    method public Exception? getLifecycleCreateException();
    method public boolean hasCreatePermission();
    method public void setHasCreatePermission(boolean);
    method public void setLifecycleCreateException(Exception?);
    property public static boolean hasCreatePermission;
    property public Exception? lifecycleCreateException;
  }

  public final class FakeRuntimeAnchor implements androidx.xr.arcore.internal.Anchor {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public FakeRuntimeAnchor(androidx.xr.runtime.math.Pose pose, optional androidx.xr.runtime.testing.AnchorHolder? anchorHolder, optional boolean isTrackingAvailable);
    method public void detach();
    method public static int getAnchorsCreatedCount();
    method public androidx.xr.arcore.internal.Anchor.PersistenceState getPersistenceState();
    method public androidx.xr.runtime.math.Pose getPose();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    method public java.util.UUID? getUuid();
    method public boolean isAttached();
    method public boolean isTrackingAvailable();
    method public void persist();
    method public static void setAnchorsCreatedCount(int);
    method public void setPersistenceState(androidx.xr.arcore.internal.Anchor.PersistenceState);
    method public void setPose(androidx.xr.runtime.math.Pose);
    method public void setTrackingState(androidx.xr.runtime.TrackingState);
    method public void setUuid(java.util.UUID?);
    property public boolean isAttached;
    property public boolean isTrackingAvailable;
    property public androidx.xr.arcore.internal.Anchor.PersistenceState persistenceState;
    property public androidx.xr.runtime.math.Pose pose;
    property public androidx.xr.runtime.TrackingState trackingState;
    property public java.util.UUID? uuid;
    field public static final int ANCHOR_RESOURCE_LIMIT = 6; // 0x6
    field public static final androidx.xr.runtime.testing.FakeRuntimeAnchor.Companion Companion;
  }

  public static final class FakeRuntimeAnchor.Companion {
    method public int getAnchorsCreatedCount();
    method public void setAnchorsCreatedCount(int);
    property public static int ANCHOR_RESOURCE_LIMIT;
    property public static int anchorsCreatedCount;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakeRuntimeArDevice implements androidx.xr.arcore.internal.ArDevice {
    ctor public FakeRuntimeArDevice();
    ctor public FakeRuntimeArDevice(optional androidx.xr.runtime.math.Pose devicePose);
    method public androidx.xr.runtime.math.Pose getDevicePose();
    method public void setDevicePose(androidx.xr.runtime.math.Pose);
    property public androidx.xr.runtime.math.Pose devicePose;
    field public static final androidx.xr.runtime.testing.FakeRuntimeArDevice.Companion Companion;
  }

  public static final class FakeRuntimeArDevice.Companion {
  }

  public final class FakeRuntimeAugmentedObject implements androidx.xr.runtime.testing.AnchorHolder androidx.xr.arcore.internal.AugmentedObject {
    ctor public FakeRuntimeAugmentedObject();
    ctor public FakeRuntimeAugmentedObject(optional androidx.xr.runtime.math.Pose centerPose, optional androidx.xr.runtime.math.FloatSize3d extents, optional androidx.xr.runtime.AugmentedObjectCategory category, optional androidx.xr.runtime.TrackingState trackingState, optional java.util.Collection<androidx.xr.arcore.internal.Anchor> anchors);
    method public androidx.xr.arcore.internal.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method public void detachAnchor(androidx.xr.arcore.internal.Anchor anchor);
    method public java.util.Collection<androidx.xr.arcore.internal.Anchor> getAnchors();
    method public androidx.xr.runtime.AugmentedObjectCategory getCategory();
    method public androidx.xr.runtime.math.Pose getCenterPose();
    method public androidx.xr.runtime.math.FloatSize3d getExtents();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public void onAnchorPersisted(androidx.xr.arcore.internal.Anchor anchor);
    method public void setCategory(androidx.xr.runtime.AugmentedObjectCategory);
    method public void setCenterPose(androidx.xr.runtime.math.Pose);
    method public void setExtents(androidx.xr.runtime.math.FloatSize3d);
    method public void setTrackingState(androidx.xr.runtime.TrackingState);
    property public java.util.Collection<androidx.xr.arcore.internal.Anchor> anchors;
    property public androidx.xr.runtime.AugmentedObjectCategory category;
    property public androidx.xr.runtime.math.Pose centerPose;
    property public androidx.xr.runtime.math.FloatSize3d extents;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakeRuntimeDepthMap implements androidx.xr.arcore.internal.DepthMap {
    ctor public FakeRuntimeDepthMap();
    ctor public FakeRuntimeDepthMap(optional int width, optional int height, optional java.nio.FloatBuffer? rawDepthMap, optional java.nio.ByteBuffer? rawConfidenceMap, optional java.nio.FloatBuffer? smoothDepthMap, optional java.nio.ByteBuffer? smoothConfidenceMap);
    method public int getHeight();
    method public java.nio.ByteBuffer? getRawConfidenceMap();
    method public java.nio.FloatBuffer? getRawDepthMap();
    method public java.nio.ByteBuffer? getSmoothConfidenceMap();
    method public java.nio.FloatBuffer? getSmoothDepthMap();
    method public int getWidth();
    method public void setHeight(int);
    method public void setRawConfidenceMap(java.nio.ByteBuffer?);
    method public void setRawDepthMap(java.nio.FloatBuffer?);
    method public void setSmoothConfidenceMap(java.nio.ByteBuffer?);
    method public void setSmoothDepthMap(java.nio.FloatBuffer?);
    method public void setWidth(int);
    property public int height;
    property public java.nio.ByteBuffer? rawConfidenceMap;
    property public java.nio.FloatBuffer? rawDepthMap;
    property public java.nio.ByteBuffer? smoothConfidenceMap;
    property public java.nio.FloatBuffer? smoothDepthMap;
    property public int width;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakeRuntimeEarth implements androidx.xr.arcore.internal.Earth {
    ctor public FakeRuntimeEarth();
    ctor public FakeRuntimeEarth(optional androidx.xr.arcore.internal.Earth.State state);
    method public androidx.xr.arcore.internal.Anchor createAnchor(double latitude, double longitude, double altitude, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion);
    method public suspend Object? createAnchorOnSurface(double latitude, double longitude, double altitudeAboveSurface, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion, androidx.xr.arcore.internal.Earth.Surface surface, kotlin.coroutines.Continuation<? super androidx.xr.arcore.internal.Anchor>);
    method public androidx.xr.arcore.internal.Earth.GeospatialPoseResult createGeospatialPoseFromDevicePose();
    method public androidx.xr.arcore.internal.Earth.GeospatialPoseResult createGeospatialPoseFromPose(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.runtime.math.Pose createPoseFromGeospatialPose(androidx.xr.runtime.math.GeospatialPose geospatialPose);
    method public androidx.xr.arcore.internal.Anchor? getNextAnchor();
    method public Exception? getNextException();
    method public androidx.xr.arcore.internal.Earth.GeospatialPoseResult? getNextGeospatialPoseResult();
    method public androidx.xr.runtime.math.Pose? getNextPose();
    method public androidx.xr.arcore.internal.Earth.State getState();
    method public void setNextAnchor(androidx.xr.arcore.internal.Anchor?);
    method public void setNextException(Exception?);
    method public void setNextGeospatialPoseResult(androidx.xr.arcore.internal.Earth.GeospatialPoseResult?);
    method public void setNextPose(androidx.xr.runtime.math.Pose?);
    method public void setState(androidx.xr.arcore.internal.Earth.State);
    property public androidx.xr.arcore.internal.Anchor? nextAnchor;
    property public Exception? nextException;
    property public androidx.xr.arcore.internal.Earth.GeospatialPoseResult? nextGeospatialPoseResult;
    property public androidx.xr.runtime.math.Pose? nextPose;
    property public androidx.xr.arcore.internal.Earth.State state;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakeRuntimeFace implements androidx.xr.arcore.internal.Face {
    ctor public FakeRuntimeFace();
    ctor public FakeRuntimeFace(optional androidx.xr.runtime.TrackingState trackingState, optional boolean isValid, optional float[] blendShapeValues, optional float[] confidenceValues);
    method public float[] getBlendShapeValues();
    method public float[] getConfidenceValues();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    method public boolean isValid();
    method public void setBlendShapeValues(float[]);
    method public void setConfidenceValues(float[]);
    method public void setTrackingState(androidx.xr.runtime.TrackingState);
    method public void setValid(boolean);
    property public float[] blendShapeValues;
    property public float[] confidenceValues;
    property public boolean isValid;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  public final class FakeRuntimeHand implements androidx.xr.arcore.internal.Hand {
    ctor public FakeRuntimeHand();
    ctor public FakeRuntimeHand(optional androidx.xr.runtime.TrackingState trackingState, optional java.nio.FloatBuffer handJointsBuffer);
    method public java.nio.FloatBuffer getHandJointsBuffer();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    method public void setHandJointsBuffer(java.nio.FloatBuffer);
    method public void setTrackingState(androidx.xr.runtime.TrackingState);
    property public java.nio.FloatBuffer handJointsBuffer;
    property public androidx.xr.runtime.TrackingState trackingState;
    field public static final androidx.xr.runtime.testing.FakeRuntimeHand.Companion Companion;
  }

  public static final class FakeRuntimeHand.Companion {
  }

  public final class FakeRuntimePlane implements androidx.xr.runtime.testing.AnchorHolder androidx.xr.arcore.internal.Plane {
    ctor public FakeRuntimePlane();
    ctor public FakeRuntimePlane(optional androidx.xr.arcore.internal.Plane.Type type, optional androidx.xr.arcore.internal.Plane.Label label, optional androidx.xr.runtime.TrackingState trackingState, optional androidx.xr.runtime.math.Pose centerPose, optional androidx.xr.runtime.math.FloatSize2d extents, optional java.util.List<androidx.xr.runtime.math.Vector2> vertices, optional androidx.xr.arcore.internal.Plane? subsumedBy, optional java.util.Collection<androidx.xr.arcore.internal.Anchor> anchors);
    method public androidx.xr.arcore.internal.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method public void detachAnchor(androidx.xr.arcore.internal.Anchor anchor);
    method public java.util.Collection<androidx.xr.arcore.internal.Anchor> getAnchors();
    method public androidx.xr.runtime.math.Pose getCenterPose();
    method public androidx.xr.runtime.math.FloatSize2d getExtents();
    method public androidx.xr.arcore.internal.Plane.Label getLabel();
    method public androidx.xr.arcore.internal.Plane? getSubsumedBy();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    method public androidx.xr.arcore.internal.Plane.Type getType();
    method public java.util.List<androidx.xr.runtime.math.Vector2> getVertices();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public void onAnchorPersisted(androidx.xr.arcore.internal.Anchor anchor);
    method public void setCenterPose(androidx.xr.runtime.math.Pose);
    method public void setExtents(androidx.xr.runtime.math.FloatSize2d);
    method public void setSubsumedBy(androidx.xr.arcore.internal.Plane?);
    method public void setTrackingState(androidx.xr.runtime.TrackingState);
    method public void setVertices(java.util.List<androidx.xr.runtime.math.Vector2>);
    property public java.util.Collection<androidx.xr.arcore.internal.Anchor> anchors;
    property public androidx.xr.runtime.math.Pose centerPose;
    property public androidx.xr.runtime.math.FloatSize2d extents;
    property public androidx.xr.arcore.internal.Plane.Label label;
    property public androidx.xr.arcore.internal.Plane? subsumedBy;
    property public androidx.xr.runtime.TrackingState trackingState;
    property public androidx.xr.arcore.internal.Plane.Type type;
    property public java.util.List<androidx.xr.runtime.math.Vector2> vertices;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class FakeRuntimeRenderViewpoint implements androidx.xr.arcore.internal.RenderViewpoint {
    ctor public FakeRuntimeRenderViewpoint();
    ctor public FakeRuntimeRenderViewpoint(optional androidx.xr.runtime.math.Pose pose, optional androidx.xr.runtime.FieldOfView fieldOfView);
    method public androidx.xr.runtime.FieldOfView getFieldOfView();
    method public androidx.xr.runtime.math.Pose getPose();
    method public void setFieldOfView(androidx.xr.runtime.FieldOfView);
    method public void setPose(androidx.xr.runtime.math.Pose);
    property public androidx.xr.runtime.FieldOfView fieldOfView;
    property public androidx.xr.runtime.math.Pose pose;
  }

}

package androidx.xr.runtime.testing.math {

  public final class MathAssertions {
    method public static void assertPose(androidx.xr.runtime.math.Pose actual, androidx.xr.runtime.math.Pose expected);
    method public static void assertPose(androidx.xr.runtime.math.Pose actual, androidx.xr.runtime.math.Pose expected, optional float epsilon);
    method public static void assertRotation(androidx.xr.runtime.math.Quaternion actual, androidx.xr.runtime.math.Quaternion expected);
    method public static void assertRotation(androidx.xr.runtime.math.Quaternion actual, androidx.xr.runtime.math.Quaternion expected, optional float epsilon);
    method public static void assertVector3(androidx.xr.runtime.math.Vector3 actual, androidx.xr.runtime.math.Vector3 expected);
    method public static void assertVector3(androidx.xr.runtime.math.Vector3 actual, androidx.xr.runtime.math.Vector3 expected, optional float epsilon);
  }

}


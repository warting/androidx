// Signature format: 4.0
package androidx.xr.arcore {

  public final class Anchor {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public Anchor(androidx.xr.runtime.internal.Anchor runtimeAnchor);
    method public static androidx.xr.arcore.AnchorCreateResult create(androidx.xr.runtime.Session session, androidx.xr.runtime.math.Pose pose);
    method public void detach();
    method public static java.util.List<java.util.UUID> getPersistedAnchorUuids(androidx.xr.runtime.Session session);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.internal.Anchor getRuntimeAnchor();
    method public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Anchor.State> getState();
    method public static androidx.xr.arcore.AnchorCreateResult load(androidx.xr.runtime.Session session, java.util.UUID uuid);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static androidx.xr.arcore.Anchor loadFromNativePointer(androidx.xr.runtime.Session session, long nativePointer);
    method public suspend Object? persist(kotlin.coroutines.Continuation<? super java.util.UUID>);
    method public static void unpersist(androidx.xr.runtime.Session session, java.util.UUID uuid);
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.runtime.internal.Anchor runtimeAnchor;
    property public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Anchor.State> state;
    field public static final androidx.xr.arcore.Anchor.Companion Companion;
  }

  public static final class Anchor.Companion {
    method public androidx.xr.arcore.AnchorCreateResult create(androidx.xr.runtime.Session session, androidx.xr.runtime.math.Pose pose);
    method public java.util.List<java.util.UUID> getPersistedAnchorUuids(androidx.xr.runtime.Session session);
    method public androidx.xr.arcore.AnchorCreateResult load(androidx.xr.runtime.Session session, java.util.UUID uuid);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.arcore.Anchor loadFromNativePointer(androidx.xr.runtime.Session session, long nativePointer);
    method public void unpersist(androidx.xr.runtime.Session session, java.util.UUID uuid);
  }

  public static final class Anchor.State {
    method public androidx.xr.runtime.math.Pose getPose();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    property public androidx.xr.runtime.math.Pose pose;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  public final class AnchorCreateIllegalState extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorCreateIllegalState();
  }

  public final class AnchorCreateNotAuthorized extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorCreateNotAuthorized();
  }

  public final class AnchorCreateResourcesExhausted extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorCreateResourcesExhausted();
  }

  public abstract sealed class AnchorCreateResult {
  }

  public final class AnchorCreateSuccess extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorCreateSuccess(androidx.xr.arcore.Anchor anchor);
    method public androidx.xr.arcore.Anchor getAnchor();
    property public androidx.xr.arcore.Anchor anchor;
  }

  public final class AnchorCreateTrackingUnavailable extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorCreateTrackingUnavailable();
  }

  public final class AnchorCreateUnsupportedLocation extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorCreateUnsupportedLocation();
  }

  public final class AnchorLoadInvalidUuid extends androidx.xr.arcore.AnchorCreateResult {
    ctor public AnchorLoadInvalidUuid();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class CreateGeospatialPoseFromPoseIllegalState extends androidx.xr.arcore.CreateGeospatialPoseFromPoseResult {
    ctor public CreateGeospatialPoseFromPoseIllegalState();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class CreateGeospatialPoseFromPoseNotTracking extends androidx.xr.arcore.CreateGeospatialPoseFromPoseResult {
    ctor public CreateGeospatialPoseFromPoseNotTracking();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public abstract sealed class CreateGeospatialPoseFromPoseResult {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class CreateGeospatialPoseFromPoseSuccess extends androidx.xr.arcore.CreateGeospatialPoseFromPoseResult {
    ctor public CreateGeospatialPoseFromPoseSuccess(androidx.xr.runtime.math.GeospatialPose pose, double horizontalAccuracy, double verticalAccuracy, double orientationYawAccuracy);
    method public double getHorizontalAccuracy();
    method public double getOrientationYawAccuracy();
    method public androidx.xr.runtime.math.GeospatialPose getPose();
    method public double getVerticalAccuracy();
    property public double horizontalAccuracy;
    property public double orientationYawAccuracy;
    property public androidx.xr.runtime.math.GeospatialPose pose;
    property public double verticalAccuracy;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class CreatePoseFromGeospatialPoseIllegalState extends androidx.xr.arcore.CreatePoseFromGeospatialPoseResult {
    ctor public CreatePoseFromGeospatialPoseIllegalState();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class CreatePoseFromGeospatialPoseNotTracking extends androidx.xr.arcore.CreatePoseFromGeospatialPoseResult {
    ctor public CreatePoseFromGeospatialPoseNotTracking();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public abstract sealed class CreatePoseFromGeospatialPoseResult {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class CreatePoseFromGeospatialPoseSuccess extends androidx.xr.arcore.CreatePoseFromGeospatialPoseResult {
    ctor public CreatePoseFromGeospatialPoseSuccess(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.runtime.math.Pose getPose();
    property public androidx.xr.runtime.math.Pose pose;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class Earth {
    method public androidx.xr.arcore.AnchorCreateResult createAnchor(double latitude, double longitude, double altitude, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion);
    method public suspend Object? createAnchorOnSurface(double latitude, double longitude, double altitudeAboveSurface, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion, androidx.xr.arcore.Earth.Surface surface, kotlin.coroutines.Continuation<? super androidx.xr.arcore.AnchorCreateResult>);
    method public androidx.xr.arcore.CreateGeospatialPoseFromPoseResult createGeospatialPoseFromDevicePose();
    method public androidx.xr.arcore.CreateGeospatialPoseFromPoseResult createGeospatialPoseFromPose(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.arcore.CreatePoseFromGeospatialPoseResult createPoseFromGeospatialPose(androidx.xr.runtime.math.GeospatialPose geospatialPose);
    method public static androidx.xr.arcore.Earth getInstance(androidx.xr.runtime.Session session);
    method public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Earth.State> getState();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.Unit>);
    property public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Earth.State> state;
    field public static final androidx.xr.arcore.Earth.Companion Companion;
  }

  public static final class Earth.Companion {
    method public androidx.xr.arcore.Earth getInstance(androidx.xr.runtime.Session session);
  }

  public static final class Earth.State {
    field public static final androidx.xr.arcore.Earth.State.Companion Companion;
    field public static final androidx.xr.arcore.Earth.State ErrorApkVersionTooOld;
    field public static final androidx.xr.arcore.Earth.State ErrorAppPreempted;
    field public static final androidx.xr.arcore.Earth.State ErrorInternal;
    field public static final androidx.xr.arcore.Earth.State ErrorNotAuthorized;
    field public static final androidx.xr.arcore.Earth.State ErrorResourceExhausted;
    field public static final androidx.xr.arcore.Earth.State Running;
    field public static final androidx.xr.arcore.Earth.State Stopped;
  }

  public static final class Earth.State.Companion {
    property public androidx.xr.arcore.Earth.State ErrorApkVersionTooOld;
    property public androidx.xr.arcore.Earth.State ErrorAppPreempted;
    property public androidx.xr.arcore.Earth.State ErrorInternal;
    property public androidx.xr.arcore.Earth.State ErrorNotAuthorized;
    property public androidx.xr.arcore.Earth.State ErrorResourceExhausted;
    property public androidx.xr.arcore.Earth.State Running;
    property public androidx.xr.arcore.Earth.State Stopped;
  }

  public static final class Earth.Surface {
    field public static final androidx.xr.arcore.Earth.Surface.Companion Companion;
    field public static final androidx.xr.arcore.Earth.Surface Rooftop;
    field public static final androidx.xr.arcore.Earth.Surface Terrain;
  }

  public static final class Earth.Surface.Companion {
    property public androidx.xr.arcore.Earth.Surface Rooftop;
    property public androidx.xr.arcore.Earth.Surface Terrain;
  }

  public final class Hand {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static androidx.xr.arcore.Hand.Handedness getHandedness(android.content.ContentResolver resolver);
    method public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Hand.State> getState();
    method public static androidx.xr.arcore.Hand? left(androidx.xr.runtime.Session session);
    method public static androidx.xr.arcore.Hand? right(androidx.xr.runtime.Session session);
    property public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Hand.State> state;
    field public static final androidx.xr.arcore.Hand.Companion Companion;
  }

  public static final class Hand.Companion {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public androidx.xr.arcore.Hand.Handedness getHandedness(android.content.ContentResolver resolver);
    method public androidx.xr.arcore.Hand? left(androidx.xr.runtime.Session session);
    method public androidx.xr.arcore.Hand? right(androidx.xr.runtime.Session session);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public enum Hand.Handedness {
    enum_constant public static final androidx.xr.arcore.Hand.Handedness LEFT;
    enum_constant public static final androidx.xr.arcore.Hand.Handedness RIGHT;
    enum_constant public static final androidx.xr.arcore.Hand.Handedness UNKNOWN;
  }

  public static final class Hand.State {
    method public java.util.Map<androidx.xr.runtime.HandJointType,androidx.xr.runtime.math.Pose> getHandJoints();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.nio.FloatBuffer getHandJointsBuffer();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    property public java.util.Map<androidx.xr.runtime.HandJointType,androidx.xr.runtime.math.Pose> handJoints;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public java.nio.FloatBuffer handJointsBuffer;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  public final class HitResult {
    method public androidx.xr.arcore.AnchorCreateResult createAnchor();
    method public float getDistance();
    method public androidx.xr.runtime.math.Pose getHitPose();
    method public androidx.xr.arcore.Trackable<androidx.xr.arcore.Trackable.State> getTrackable();
    property public float distance;
    property public androidx.xr.runtime.math.Pose hitPose;
    property public androidx.xr.arcore.Trackable<androidx.xr.arcore.Trackable.State> trackable;
  }

  public final class Interaction {
    method public static java.util.List<androidx.xr.arcore.HitResult> hitTest(androidx.xr.runtime.Session session, androidx.xr.runtime.math.Ray ray);
  }

  public final class PerceptionState {
    method public androidx.xr.arcore.Hand? getLeftHand();
    method public androidx.xr.arcore.Hand? getRightHand();
    method public kotlin.time.ComparableTimeMark getTimeMark();
    method public java.util.Collection<androidx.xr.arcore.Trackable<androidx.xr.arcore.Trackable.State>> getTrackables();
    property public androidx.xr.arcore.Hand? leftHand;
    property public androidx.xr.arcore.Hand? rightHand;
    property public kotlin.time.ComparableTimeMark timeMark;
    property public java.util.Collection<androidx.xr.arcore.Trackable<androidx.xr.arcore.Trackable.State>> trackables;
  }

  public final class PerceptionStateExtenderKt {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static androidx.xr.arcore.PerceptionState? getPerceptionState(androidx.xr.runtime.CoreState);
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public static androidx.xr.arcore.PerceptionState? androidx.xr.runtime.CoreState.perceptionState;
  }

  public final class Plane implements androidx.xr.arcore.Trackable<androidx.xr.arcore.Plane.State> {
    method public androidx.xr.arcore.AnchorCreateResult createAnchor(androidx.xr.runtime.math.Pose pose);
    method public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Plane.State> getState();
    method public androidx.xr.arcore.Plane.Type getType();
    method public static kotlinx.coroutines.flow.StateFlow<java.util.Collection<androidx.xr.arcore.Plane>> subscribe(androidx.xr.runtime.Session session);
    property public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Plane.State> state;
    property public androidx.xr.arcore.Plane.Type type;
    field public static final androidx.xr.arcore.Plane.Companion Companion;
  }

  public static final class Plane.Companion {
    method public kotlinx.coroutines.flow.StateFlow<java.util.Collection<androidx.xr.arcore.Plane>> subscribe(androidx.xr.runtime.Session session);
  }

  public static final class Plane.Label {
    field public static final androidx.xr.arcore.Plane.Label CEILING;
    field public static final androidx.xr.arcore.Plane.Label.Companion Companion;
    field public static final androidx.xr.arcore.Plane.Label FLOOR;
    field public static final androidx.xr.arcore.Plane.Label TABLE;
    field public static final androidx.xr.arcore.Plane.Label UNKNOWN;
    field public static final androidx.xr.arcore.Plane.Label WALL;
  }

  public static final class Plane.Label.Companion {
    property public androidx.xr.arcore.Plane.Label CEILING;
    property public androidx.xr.arcore.Plane.Label FLOOR;
    property public androidx.xr.arcore.Plane.Label TABLE;
    property public androidx.xr.arcore.Plane.Label UNKNOWN;
    property public androidx.xr.arcore.Plane.Label WALL;
  }

  public static final class Plane.State implements androidx.xr.arcore.Trackable.State {
    method public androidx.xr.runtime.math.Pose getCenterPose();
    method public androidx.xr.runtime.math.Vector2 getExtents();
    method public androidx.xr.arcore.Plane.Label getLabel();
    method public androidx.xr.arcore.Plane? getSubsumedBy();
    method public androidx.xr.runtime.TrackingState getTrackingState();
    method public java.util.List<androidx.xr.runtime.math.Vector2> getVertices();
    property public androidx.xr.runtime.math.Pose centerPose;
    property public androidx.xr.runtime.math.Vector2 extents;
    property public androidx.xr.arcore.Plane.Label label;
    property public androidx.xr.arcore.Plane? subsumedBy;
    property public androidx.xr.runtime.TrackingState trackingState;
    property public java.util.List<androidx.xr.runtime.math.Vector2> vertices;
  }

  public static final class Plane.Type {
    field public static final androidx.xr.arcore.Plane.Type.Companion Companion;
    field public static final androidx.xr.arcore.Plane.Type HORIZONTAL_DOWNWARD_FACING;
    field public static final androidx.xr.arcore.Plane.Type HORIZONTAL_UPWARD_FACING;
    field public static final androidx.xr.arcore.Plane.Type VERTICAL;
  }

  public static final class Plane.Type.Companion {
    property public androidx.xr.arcore.Plane.Type HORIZONTAL_DOWNWARD_FACING;
    property public androidx.xr.arcore.Plane.Type HORIZONTAL_UPWARD_FACING;
    property public androidx.xr.arcore.Plane.Type VERTICAL;
  }

  public interface Trackable<State> {
    method public androidx.xr.arcore.AnchorCreateResult createAnchor(androidx.xr.runtime.math.Pose pose);
    method public kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Trackable.State> getState();
    property public abstract kotlinx.coroutines.flow.StateFlow<androidx.xr.arcore.Trackable.State> state;
  }

  public static interface Trackable.State {
    method public androidx.xr.runtime.TrackingState getTrackingState();
    property public abstract androidx.xr.runtime.TrackingState trackingState;
  }

}


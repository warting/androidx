// Signature format: 4.0
package androidx.xr.arcore.projected {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedArDevice implements androidx.xr.arcore.internal.ArDevice {
    ctor public ProjectedArDevice();
    ctor public ProjectedArDevice(optional androidx.xr.runtime.math.Pose devicePose);
    method public androidx.xr.runtime.math.Pose getDevicePose();
    method public void setDevicePose(androidx.xr.runtime.math.Pose);
    property public androidx.xr.runtime.math.Pose devicePose;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedEarth implements androidx.xr.arcore.internal.Earth {
    method public androidx.xr.arcore.internal.Anchor createAnchor(double latitude, double longitude, double altitude, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion);
    method public suspend Object? createAnchorOnSurface(double latitude, double longitude, double altitudeAboveSurface, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion, androidx.xr.arcore.internal.Earth.Surface surface, kotlin.coroutines.Continuation<? super androidx.xr.arcore.internal.Anchor>);
    method public androidx.xr.arcore.internal.Earth.GeospatialPoseResult createGeospatialPoseFromDevicePose();
    method public androidx.xr.arcore.internal.Earth.GeospatialPoseResult createGeospatialPoseFromPose(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.runtime.math.Pose createPoseFromGeospatialPose(androidx.xr.runtime.math.GeospatialPose geospatialPose);
    method public androidx.xr.arcore.internal.Earth.State getState();
    property public androidx.xr.arcore.internal.Earth.State state;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedManager implements androidx.xr.runtime.internal.LifecycleManager {
    method public void configure(androidx.xr.runtime.Config config);
    method public void create();
    method public androidx.xr.runtime.Config getConfig();
    method public void pause();
    method public void resume();
    method public void stop();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark>);
    property public androidx.xr.runtime.Config config;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedPerceptionManager implements androidx.xr.arcore.internal.PerceptionManager {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public suspend Object? checkVpsAvailability(double latitude, double longitude, kotlin.coroutines.Continuation<? super androidx.xr.runtime.VpsAvailabilityResult>);
    method public androidx.xr.arcore.internal.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.arcore.internal.ArDevice getArDevice();
    method public androidx.xr.arcore.internal.Earth getEarth();
    method public androidx.xr.arcore.internal.DepthMap? getLeftDepthMap();
    method public androidx.xr.arcore.internal.Hand? getLeftHand();
    method public androidx.xr.arcore.projected.ProjectedRuntimeRenderViewpoint? getLeftRenderViewpoint();
    method public androidx.xr.arcore.internal.DepthMap? getMonoDepthMap();
    method public androidx.xr.arcore.projected.ProjectedRuntimeRenderViewpoint? getMonoRenderViewpoint();
    method public java.util.List<java.util.UUID> getPersistedAnchorUuids();
    method public androidx.xr.arcore.internal.DepthMap? getRightDepthMap();
    method public androidx.xr.arcore.internal.Hand? getRightHand();
    method public androidx.xr.arcore.projected.ProjectedRuntimeRenderViewpoint? getRightRenderViewpoint();
    method public java.util.Collection<androidx.xr.arcore.internal.Trackable> getTrackables();
    method public androidx.xr.arcore.internal.Face? getUserFace();
    method public java.util.List<androidx.xr.arcore.internal.HitResult> hitTest(androidx.xr.runtime.math.Ray ray);
    method public androidx.xr.arcore.internal.Anchor loadAnchor(java.util.UUID uuid);
    method public androidx.xr.arcore.internal.Anchor loadAnchorFromNativePointer(long nativePointer);
    method public void setDisplayRotation(int rotation, int width, int height);
    method public void unpersistAnchor(java.util.UUID uuid);
    property public androidx.xr.arcore.internal.ArDevice arDevice;
    property public androidx.xr.arcore.internal.Earth earth;
    property public androidx.xr.arcore.internal.DepthMap? leftDepthMap;
    property public androidx.xr.arcore.internal.Hand? leftHand;
    property public androidx.xr.arcore.projected.ProjectedRuntimeRenderViewpoint? leftRenderViewpoint;
    property public androidx.xr.arcore.internal.DepthMap? monoDepthMap;
    property public androidx.xr.arcore.projected.ProjectedRuntimeRenderViewpoint? monoRenderViewpoint;
    property public androidx.xr.arcore.internal.DepthMap? rightDepthMap;
    property public androidx.xr.arcore.internal.Hand? rightHand;
    property public androidx.xr.arcore.projected.ProjectedRuntimeRenderViewpoint? rightRenderViewpoint;
    property public java.util.Collection<androidx.xr.arcore.internal.Trackable> trackables;
    property public androidx.xr.arcore.internal.Face? userFace;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedRuntime implements androidx.xr.arcore.internal.PerceptionRuntime {
    method public androidx.xr.arcore.projected.ProjectedManager getLifecycleManager();
    method public androidx.xr.arcore.projected.ProjectedPerceptionManager getPerceptionManager();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark?>);
    property public androidx.xr.arcore.projected.ProjectedManager lifecycleManager;
    property public androidx.xr.arcore.projected.ProjectedPerceptionManager perceptionManager;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedRuntimeFactory implements androidx.xr.runtime.internal.PerceptionRuntimeFactory {
    ctor public ProjectedRuntimeFactory();
    method public androidx.xr.arcore.internal.PerceptionRuntime createRuntime(android.app.Activity activity, kotlin.coroutines.CoroutineContext coroutineContext);
    method public java.util.Set<androidx.xr.runtime.internal.Feature> getRequirements();
    property public java.util.Set<androidx.xr.runtime.internal.Feature> requirements;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class ProjectedRuntimeRenderViewpoint implements androidx.xr.arcore.internal.RenderViewpoint {
    ctor public ProjectedRuntimeRenderViewpoint();
    ctor public ProjectedRuntimeRenderViewpoint(optional androidx.xr.runtime.math.Pose pose, optional androidx.xr.runtime.FieldOfView fieldOfView);
    method public androidx.xr.runtime.FieldOfView getFieldOfView();
    method public androidx.xr.runtime.math.Pose getPose();
    method public void setFieldOfView(androidx.xr.runtime.FieldOfView);
    method public void setPose(androidx.xr.runtime.math.Pose);
    property public androidx.xr.runtime.FieldOfView fieldOfView;
    property public androidx.xr.runtime.math.Pose pose;
  }

}


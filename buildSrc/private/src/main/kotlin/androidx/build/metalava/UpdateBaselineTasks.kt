/*
 * Copyright 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.build.metalava

import java.io.File
import javax.inject.Inject
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.OutputFiles
import org.gradle.api.tasks.TaskAction
import org.gradle.workers.WorkerExecutor

@CacheableTask
internal abstract class UpdateApiLintBaselineTask
@Inject
constructor(workerExecutor: WorkerExecutor) : SourceMetalavaTask(workerExecutor) {
    init {
        group = "API"
        description =
            "Updates an API lint baseline file (api/api_lint.ignore) to match the " +
                "current set of violations. Only use a baseline " +
                "if you are in a library without Android dependencies, or when enabling a new " +
                "lint check, and it is prohibitively expensive / not possible to fix the errors " +
                "generated by enabling this lint check. "
    }

    @OutputFile fun getOutputApiLintBaseline(): File = baselines.get().apiLintFile

    @TaskAction
    fun updateBaseline() {
        check(bootClasspath.files.isNotEmpty()) { "Android boot classpath not set." }
        val baselineFile = baselines.get().apiLintFile
        val checkArgs =
            getGenerateApiArgs(
                createProjectXmlFile(),
                sourcePaths.files.filter { it.exists() },
                // API lint is not run on bytecode-only APIs, so don't bother processing the jar
                // when generating a baseline.
                compiledSources = null,
                null,
                GenerateApiMode.PublicApi,
                ApiLintMode.CheckBaseline(baselineFile, targetsJavaConsumers.get()),
                // API version history doesn't need to be generated
                emptyList(),
                manifestPath.orNull?.asFile?.absolutePath,
            )
        val args = checkArgs + getCommonBaselineUpdateArgs(baselineFile)

        runWithArgs(args)
    }
}

@CacheableTask
internal abstract class IgnoreApiChangesTask @Inject constructor(workerExecutor: WorkerExecutor) :
    CompatibilityMetalavaTask(workerExecutor) {
    init {
        description =
            "Updates an API tracking baseline file (api/X.Y.Z.ignore) to match the " +
                "current set of violations"
    }

    // Declaring outputs prevents Gradle from rerunning this task if the inputs haven't changed
    @OutputFiles
    fun getTaskOutputs(): List<File>? {
        val apiBaselinesLocation = baselines.get()
        return listOf(apiBaselinesLocation.publicApiFile, apiBaselinesLocation.restrictedApiFile)
    }

    @TaskAction
    fun exec() {
        check(bootClasspath.files.isNotEmpty()) { "Android boot classpath not set." }

        val freezeApis = shouldFreezeApis(referenceApi.get().version(), version.get())
        updateBaseline(restricted = false, freezeApis)
        if (restrictedApisExist()) {
            updateBaseline(restricted = true, freezeApis)
        }
    }

    /**
     * Updates the contents of the baseline file to specify an exception for every compatibility
     * error found comparing the previous API to the current.
     *
     * @param restricted whether this compatibility check is for restricted APIs
     * @param freezeApis whether APIs are frozen and no changes should be allowed
     */
    private fun updateBaseline(restricted: Boolean, freezeApis: Boolean) {
        val baseline = getBaselineFile(restricted)
        val args = buildList {
            addAll(getCommonBaselineUpdateArgs(baseline))
            addAll(getCompatibilityArguments(restricted, freezeApis))

            add("--baseline")
            add(baseline.toString())
        }
        runWithArgs(args)
    }
}

private fun getCommonBaselineUpdateArgs(baselineFile: File): List<String> {
    // Create the baseline file if it does exist, as Metalava cannot handle non-existent files.
    baselineFile.createNewFile()
    return mutableListOf(
        "--update-baseline",
        baselineFile.toString(),
        "--pass-baseline-updates",
        "--delete-empty-baselines",
        "--format=v4",
    )
}

// Signature format: 4.0
package androidx.appfunctions {

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget.FUNCTION) public @interface AppFunction {
    method public abstract boolean isEnabled() default true;
    property public abstract boolean isEnabled;
  }

  public final class AppFunctionConfiguration {
    method public java.util.Map<java.lang.Class<? extends java.lang.Object?>,kotlin.jvm.functions.Function0<java.lang.Object>> getEnclosingClassFactories();
    property public java.util.Map<java.lang.Class<? extends java.lang.Object?>,kotlin.jvm.functions.Function0<java.lang.Object>> enclosingClassFactories;
  }

  public static final class AppFunctionConfiguration.Builder {
    ctor public AppFunctionConfiguration.Builder();
    method public <T> androidx.appfunctions.AppFunctionConfiguration.Builder addEnclosingClassFactory(Class<T> enclosingClass, kotlin.jvm.functions.Function0<? extends T> factory);
    method public androidx.appfunctions.AppFunctionConfiguration build();
  }

  public static interface AppFunctionConfiguration.Provider {
    method public androidx.appfunctions.AppFunctionConfiguration getAppFunctionConfiguration();
    property public abstract androidx.appfunctions.AppFunctionConfiguration appFunctionConfiguration;
  }

  public final class AppFunctionManagerCompat {
    method @RequiresPermission(value="android.permission.EXECUTE_APP_FUNCTIONS", conditional=true) public suspend Object? executeAppFunction(androidx.appfunctions.ExecuteAppFunctionRequest request, kotlin.coroutines.Continuation<? super androidx.appfunctions.ExecuteAppFunctionResponse>);
    method public static androidx.appfunctions.AppFunctionManagerCompat? getInstance(android.content.Context context);
    method @RequiresPermission(value="android.permission.EXECUTE_APP_FUNCTIONS", conditional=true) public suspend Object? isAppFunctionEnabled(String packageName, String functionId, kotlin.coroutines.Continuation<? super java.lang.Boolean>);
    method public suspend Object? isAppFunctionEnabled(String functionId, kotlin.coroutines.Continuation<? super java.lang.Boolean>);
    method @RequiresPermission(value="android.permission.EXECUTE_APP_FUNCTIONS", conditional=true) public kotlinx.coroutines.flow.Flow<java.util.List<androidx.appfunctions.metadata.AppFunctionMetadata>> observeAppFunctions(androidx.appfunctions.AppFunctionSearchSpec searchSpec);
    method @RequiresPermission(value="android.permission.EXECUTE_APP_FUNCTIONS", conditional=true) public suspend Object? setAppFunctionEnabled(String functionId, int newEnabledState, kotlin.coroutines.Continuation<? super kotlin.Unit>);
    field public static final int APP_FUNCTION_STATE_DEFAULT = 0; // 0x0
    field public static final int APP_FUNCTION_STATE_DISABLED = 2; // 0x2
    field public static final int APP_FUNCTION_STATE_ENABLED = 1; // 0x1
    field public static final androidx.appfunctions.AppFunctionManagerCompat.Companion Companion;
  }

  public static final class AppFunctionManagerCompat.Companion {
    method public androidx.appfunctions.AppFunctionManagerCompat? getInstance(android.content.Context context);
    property public static int APP_FUNCTION_STATE_DEFAULT;
    property public static int APP_FUNCTION_STATE_DISABLED;
    property public static int APP_FUNCTION_STATE_ENABLED;
  }

  public final class AppFunctionSearchSpec {
    ctor public AppFunctionSearchSpec();
    ctor public AppFunctionSearchSpec(optional java.util.Set<java.lang.String>? packageNames);
    ctor public AppFunctionSearchSpec(optional java.util.Set<java.lang.String>? packageNames, optional String? schemaCategory);
    ctor public AppFunctionSearchSpec(optional java.util.Set<java.lang.String>? packageNames, optional String? schemaCategory, optional String? schemaName);
    ctor public AppFunctionSearchSpec(optional java.util.Set<java.lang.String>? packageNames, optional String? schemaCategory, optional String? schemaName, optional int minSchemaVersion);
    method public int getMinSchemaVersion();
    method public java.util.Set<java.lang.String>? getPackageNames();
    method public String? getSchemaCategory();
    method public String? getSchemaName();
    property public int minSchemaVersion;
    property public java.util.Set<java.lang.String>? packageNames;
    property public String? schemaCategory;
    property public String? schemaName;
  }

}

